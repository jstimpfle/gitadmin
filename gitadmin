#!/usr/bin/python3

import os, sys, re
import sqlite3
import readline, cmd
import inspect

is_stdin_tty  = os.isatty(sys.stdin.fileno())
is_stdout_tty = os.isatty(sys.stdout.fileno())
is_stderr_tty = os.isatty(sys.stderr.fileno())

# **********************************************************************
# CONFIG
# **********************************************************************

config_basedir = 'gitadmin-basedir'

# **********************************************************************
# REGEXEN
# **********************************************************************

# These regexen can be tweaked, but one must be careful not to violate internal
# assumptions:
# - repos and domains are valid filepath components (x not in ['.','..'] and '/' not in x)
# - other than comments which are always printed in the last column, no whitespace (which would prohibit scripting)
# - user names go to the authorized_keys file. Dangerous!
# - there may be other, undocumented assumptions. It's probably unwise to allow shell special characters in non-comment data.

username_regex      = r"""[a-z][a-z0-9]{1,15}"""
domainname_regex    = r"""[a-z][a-z0-9]{1,15}"""
reponame_regex      = r"""[a-zA-Z][a-zA-Z0-9_-]{1,15}"""
sshkey_algo_regex   = r"""(?:ssh-ed25519|ssh-rsa|ssh-dss|ecdsa-sha2-nistp256|ecdsa-sha2-nistp384|ecdsa-sha2-nistp521)"""
sshkey_key_regex    = r"""[a-zA-Z0-9+/]{32,8192}={0,2}"""
usercomment_regex   = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
domaincomment_regex = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
repocomment_regex   = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
sshkeycomment_regex = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""

# **********************************************************************
# GLOBAL STATE
# **********************************************************************

# (effective) gitadmin user
loguser = None

# indicates whether we're running the su command
running_su = False

# DB connection
conn = None

# **********************************************************************
# STRINGS
# **********************************************************************

help_short = r"""
gitadmin invocation:

    gitadmin --help
    gitadmin --init
    gitadmin [-u USER] ARGS...
    gitadmin [-u USER] -c CMD
    gitadmin [-u USER]
    SSH_ORIGINAL_CMD=GITCMD gitadmin [-u USER]
"""

help_long = help_short + r"""
gitadmin --help

    Print this help message.

gitadmin --init

    Initialize a new gitadmin environment. gitadmin aborts if an
    existing environment is found. The base directory 'gitadmin-basedir'
    (or whatever was configured by changing the program code) must
    exist, and be empty.  Filepath customization is currently done
    after initialization by moving the objects which were created in
    the base directory somewhere else, and putting symlinks into the
    base directory.

gitadmin [-u USER] ARGS...

    The argument list ARGS is interpreted as a (pre-split) gitadmin
    command (possible commands are listed by the `info' command). If
    -u USER is given, interpret the command as this gitadmin user.
    For example, a valid invocation from the shell (sh) would be

        $ gitadmin create_user john "John Doe"

gitadmin [-u USER] -c CMD

    In the fourth case, run the gitadmin shell in noninteractive mode,
    interpreting CMD which must be a gitadmin shell command (a single
    argument). The gitadmin shell syntax is explained a little in the
    next paragraph. If -u USER is given, run as the given gitadmin
    user. Example gitadmin invocation from sh:

        $ gitadmin -u john -c 'set_perm john testrepo jane RW'

gitadmin [-u USER]

    Run the gitadmin shell, interpreting commands read from stdin.
    If standard input and standard error are both connected to ttys, an
    interactive with command-line editing and (session) history is run.
    If -u USER is given, run the shell as this gitadmin user. Commands
    are read line by line, and split into words with a simple algorithm
    involving quotation mark (") as quote character and backslash (\)
    as escape character, similar to the quoting algorithm known from
    sh. Example: This\ is" all one "word.

    Example gitadmin commands:

        gitadmin> create_repo john testrepo "John's repo, in domain \"john\""
        gitadmin> set_perm john testrepo john RW
        gitadmin> set_perm john testrepo jane R

    (The `gitadmin> ' prompts are printed by gitadmin in interactive mode,
    to indicate that it is waiting for the next command).

SSH_ORIGINAL_CMD=GITCMD gitadmin [-u USER]

    Validate the environment variable SSH_ORIGINAL_CMD as an allowed
    git request (git-receive-pack 'DOMAIN/REPO' or git-upload-pack
    'DOMAIN/REPO', as can be observed with the git reference
    implementation) and execute it as a subprocess if the requesting user
    has appropriate permission.  This allows the actual git traffic, like
    pushes and pulls. The idea is that the system administrator sets
    up a `gitadmin' system user, and configures the `authorized_keys'
    file which is maintained by gitadmin as the SshAuthorizedKeysFile
    for that system user.
"""

shell_intro = "Welcome to gitadmin. Type 'info' for a list of available commands"

shell_prompt = "gitadmin> "

commands_listing = r"""
Root admin commands:

  su USER CMD...
  create_domain DOMAIN COMMENT
  delete_domain DOMAIN
  create_user USER COMMENT
  delete_user USER
                                             User commands:
Domain admin commands:
                                               info
  admins DOMAIN                                whoami
  repos DOMAIN                                 users
  repo_perms DOMAIN REPO                       domains
  set_domain_admin DOMAIN USER                 perms
  unset_domain_admin DOMAIN USER               sshkeys
  create_repo DOMAIN REPO COMMENT              add_sshkey
  delete_repo DOMAIN REPO                      remove_sshkey
  set_repo_comment DOMAIN REPO COMMENT         guests
  set_perm DOMAIN REPO USER <none|R|RW>        create_guest USER COMMENT
  set_public DOMAIN REPO <true|false>          delete_guest USER
"""

sql_schema = r"""
CREATE TABLE user
( user    VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, PRIMARY KEY (user)
);

CREATE TABLE domain
( domain  VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, PRIMARY KEY (domain)
);

CREATE TABLE repo
( domain  VARCHAR NOT NULL
, repo    VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, PRIMARY KEY (domain, repo)
, FOREIGN KEY (domain) REFERENCES domain (domain)
);

CREATE TABLE sshkey
( user    VARCHAR NOT NULL
, algo    VARCHAR NOT NULL
, key     VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, PRIMARY KEY (user, key)
, FOREIGN KEY (user) REFERENCES user (user)
);

CREATE TABLE admin
( domain VARCHAR NOT NULL
, user   VARCHAR NOT NULL
--
, PRIMARY KEY (domain, user)
, FOREIGN KEY (domain) REFERENCES domain (domain)
, FOREIGN KEY (user)   REFERENCES user   (user)
);

CREATE TABLE perm
( domain VARCHAR NOT NULL
, repo   VARCHAR NOT NULL
, user   VARCHAR NOT NULL
, perm   VARCHAR NOT NULL
--
, PRIMARY KEY (domain, repo, user)
, FOREIGN KEY (domain) REFERENCES domain (domain)
, FOREIGN KEY (repo)   REFERENCES repo   (repo)
, FOREIGN KEY (user)   REFERENCES user   (user)
, CHECK (perm == "R" OR perm == "RW")
);

CREATE TABLE publicro
( domain VARCHAR NOT NULL
, repo   VARCHAR NOT NULL
--
, PRIMARY KEY (domain, repo)
, FOREIGN KEY (domain) REFERENCES domain (domain)
, FOREIGN KEY (repo)   REFERENCES repo   (repo)
);

CREATE TABLE guest
( guest  VARCHAR NOT NULL
, host   VARCHAR NOT NULL
--
, PRIMARY KEY (guest, host)
, FOREIGN KEY (guest) REFERENCES user (user)
, FOREIGN KEY (host)  REFERENCES user (user)
);
"""

# **********************************************************************
# Exceptions
# **********************************************************************

#
# Custom exceptions modeling gitadmin semantics. All occurring expected
# exceptions are immediately converted to one of these custom exceptions.
#
# Any other exceptions are bugs.
#

class GA_Exception(Exception):
    """base class for all gitadmin exceptions"""
    msg = "Unknown gitadmin error"

class GA_FSError(GA_Exception):
    """An error from the filesystem or the OS during a gitadmin operation"""
    msg = "Filesystem or OS Error"

class GA_IntegrityError(GA_Exception):
    """An operation could not be performed because a DB constraint was
       violated, for otherwise unknown reasons"""
    msg = "Unknown database error"

class GA_Exists(GA_Exception):
    """An attempt was made to create an object which already exists"""
    msg = "Object already exists"

class GA_NotFound(GA_Exception):
    """An object reference could not be resolved"""
    msg = "No such object"

class GA_FailedDependencies(GA_Exception):
    """An operation could not be performed because some other operation needs
       to be performed first (like deleting all repos from a domain before the
       domain can be deleted)"""
    msg = "Operation not possible"

class GA_Invalid(GA_Exception):
    """A command could not be parsed, or wrong number of arguments, or one or
       more arguments did not match the according regular expression"""
    msg = "Invalid command"

class GA_AuthError(GA_Exception):
    """A parsed command could not be processed due to insufficient
       authorization"""
    msg = "Authentication failed"

# **********************************************************************
# VARIOUS HELPER FUNCTIONS
# **********************************************************************

# regex matching

def exact_match(regex, value):
    return re.match(r'^' + regex + r'$', value) is not None

# file system

def mkdir(dirpath):
    try:
        os.mkdir(dirpath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to create directory: {}".format(e))

def rmdir(dirpath):
    try:
        os.rmdir(dirpath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to remove directory: {}".format(e))

def symlink(filepath, linkpath):
    try:
        os.symlink(filepath, linkpath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to create symlink: {}".format(e))

def unlink(filepath):
    try:
        os.unlink(filepath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to unlink: {}".format(e))

def write_file(filepath, rawbytes):
    try:
        with open(filepath, 'wb') as f:
            f.write(rawbytes)
    except (OSError, IOError) as e:
        raise GA_FSError("Failed to write file: {}".format(e))

# Database

def create_db():
    if os.path.exists(path_database()):
        raise GA_Exception("Database exists. Refusing to create")
    try:
        conn = sqlite3.connect(path_database(), isolation_level=None)
        conn.execute("PRAGMA FOREIGN_KEYS = ON")
        conn.executescript(sql_schema)
        conn.close()
    except sqlite3.Error as e:
        raise GA_Exception("Error creating Database: {}".format(e))

def connect_db():
    global conn
    if not os.path.exists(path_database()):
        raise GA_Exception("Database doesn't exist. Call 'gitadmin --init'")
    try:
        conn = sqlite3.connect(path_database(), isolation_level=None)
        conn.execute("PRAGMA FOREIGN_KEYS = ON")
    except sqlite3.Error as e:
        raise GA_Exception("Error opening Database: {}".format(e))

def disconnect_db():
    global conn
    try:
        conn.close()
    except sqlite3.Error as e:
        raise GA_Exception("Error closing Database: {}".format(e))
    conn = None

def with_db(fun, *args):
    connect_db()
    try:
        fun(*args)
    finally:
        disconnect_db()

def start_db_transaction():
    global conn
    try:
        conn.execute("BEGIN TRANSACTION")
    except sqlite3.Error as e:
        raise GA_Exception("Error starting DB transaction: {}".format(e))

def end_db_transaction():
    global conn
    try:
        conn.execute("END TRANSACTION")
    except sqlite3.Error as e:
        raise GA_Exception("Error committing DB transaction: {}".format(e))

def abort_db_transaction():
    global conn
    try:
        conn.execute("ROLLBACK")
    except sqlite3.Error as e:
        raise GA_Exception("Error while aborting DB transaction: {}".format(e))

def select(sql, args=()):
    global conn
    rs = conn.execute(sql, args)
    return list(rs)

def delete(sql, args=()):
    global conn
    try:
        conn.execute(sql, args)
        rs = conn.execute("SELECT CHANGES()")
        return list(rs)[0][0]
    except sqlite3.IntegrityError as e:
        raise GA_IntegrityError(e)

def insert(sql, args=()):
    global conn
    try:
        conn.execute(sql, args)
    except sqlite3.IntegrityError as e:
        raise GA_IntegrityError("Database integrity constraint violated")

# Validation

def need_valid_username(user):
    if not exact_match(username_regex, user):
        raise GA_Invalid("'{}' is not a valid user name".format(user))

def need_valid_domainname(domain):
    if not exact_match(domainname_regex, domain):
        raise GA_Invalid("'{}' is not a valid domain name".format(domain))

def need_valid_reponame(repo):
    if not exact_match(reponame_regex, repo):
        raise GA_Invalid("'{}' is not a valid repo name".format(repo))

def need_valid_usercomment(comment):
    if not exact_match(usercomment_regex, comment):
        raise GA_Invalid("'{}' is not a valid user comment".format(comment))

def need_valid_domaincomment(comment):
    if not exact_match(domaincomment_regex, comment):
        raise GA_Invalid("'{}' is not a valid domain comment".format(comment))

def need_valid_repocomment(comment):
    if not exact_match(repocomment_regex, comment):
        raise GA_Invalid("'{}' is not a valid repo comment".format(comment))

def need_valid_boolean(boolean):
    if boolean not in ['true', 'false']:
        raise GA_Invalid("'{}' is not a valid boolean. Need 'true' or 'false'".format(boolean))

# Authorization

def require_root_admin():
    if loguser is not None:
        raise GA_AuthError("root admin privileges needed")

def require_domain_admin(domain):
    adm = db_list_domain_admins(domain)
    if loguser not in map(lambda r: r[1], adm):
        raise GA_AuthError("domain admin privileges needed")

def require_not_su():
    if running_su:
        raise GA_AuthError("nesting of 'su' command not allowed")

# Formatting

def format_authorized_keys(rs):
    return ''.join('command="gitadmin -u {}" {} {} {}\n'.format(user, algo, key, comment)
                   for user, algo, key, comment in rs)

def format_table(rs):
    # TODO: Not here
    if not is_stdout_tty:
        return ''.join('\t'.join(c for c in r) + '\n' for r in rs)

    lss = zip(*[[len(c) for c in r] for r in rs])
    ls = [max(ls) for ls in lss]
    xs = [[str(c).ljust(l) for c, l in list(zip(r, ls))[:-1]] + [r[-1]] for r in rs]
    return ''.join('\t'.join(r) + '\n' for r in rs)

# **********************************************************************
# FILE PATHS
# **********************************************************************

def path_base_dir():
    return os.path.join(config_basedir)

def path_repos_dir():
    return os.path.join(config_basedir, 'repos')

def path_authorized_keys():
    return os.path.join(config_basedir, 'authorized_keys')

def path_database():
    return os.path.join(config_basedir, 'gitadmin.sqlite3')

def path_domain_dir(domain):
    return os.path.join(config_basedir, 'repos', domain)

def path_repo_dir(domain, repo):
    return os.path.join(config_basedir, 'repos', domain, repo)

def path_repocomment(domain, repo):
    return os.path.join(config_basedir, 'repos', domain, repo, 'description')

def path_publicro_dir():
    return os.path.join(config_basedir, 'publicro')

def path_publicro_domain_dir(domain):
    return os.path.join(config_basedir, 'publicro', domain)

def path_publicro_repo_symlink(domain, repo):
    return os.path.join(config_basedir, 'publicro', domain, repo)

# **********************************************************************
# DB ACCESS LAYER
# **********************************************************************

#
# These functions translate between the relational view of the
# database and the more object-oriented gitadmin view.
#
# Instead of using a complicated ORM mapper, let's just write some ad-hoc code.
#
# - db_insert_* functions raise GA_Exists if the "object" already exists.
# - db_delete_* functions raise GA_NotFound if the "object" doesn't exist.
#   They might also raise GA_FailedDependencies if the "object" has remaining
#   dependencies.
# - db_list_* functions raise exceptions if a reference does not exist
#   (e.g. if a domain's repos should be listed, but there's no such domain).
#   Nevertheless, db_list_* functions return flat tuples.
# - db_set_* and db_clear_* return None. They are idempotent. GA_NotFound is
#   raised when a referenced object doesn't exist.
#

def db_list_users():
    rows = select("SELECT user, comment FROM user")
    return format_table(rows)

def db_list_guests():
    return select("SELECT user, comment FROM user, guest WHERE user = guest")

def db_list_sshkeys():
    return select("SELECT user, algo, key, comment FROM sshkey")

def db_list_domains():
    return select("SELECT domain, comment FROM domain")

def db_list_repos():
    return select("SELECT domain, repo, comment FROM repo")

def db_list_admins():
    return select("SELECT domain, user FROM admin")

def db_list_user_perms(user):
    return select("SELECT domain, repo, user, perm FROM perm WHERE user = ?", (user,))

def db_list_user_guests(user):
    return select("SELECT user, comment FROM user, guest WHERE user = guest AND host = ?", (user,))

def db_list_user_sshkeys(user):
    return select("SELECT user, algo, key, comment FROM sshkey WHERE user = ?", (user,))

def db_list_domain_admins(domain):
    return select("SELECT domain, user FROM admin WHERE domain = ?", (domain,))

def db_list_domain_repos(domain):
    return select("SELECT domain, repo, comment FROM repo WHERE domain = ?", (domain,))

def db_list_user_domains(user):
    return select("SELECT domain, user FROM admin WHERE user = ?", (user,))

def db_list_repo_perms(domain, repo):
    return select("SELECT domain, repo, user, perm FROM perm WHERE domain = ? AND repo = ?", (user,))

def db_insert_user(user, comment):
    try:
        insert("INSERT INTO user (user, comment) VALUES (?, ?)", (user, comment))
    except GA_IntegrityError:
        raise GA_Exists("User already exists")

def db_insert_domain(domain, comment):
    try:
        insert("INSERT INTO domain (domain, comment) VALUES (?, ?)", (domain, comment))
    except GA_IntegrityError:
        raise GA_Exists("Domain already exists")

def db_insert_repo(domain, repo, comment):
    # assumption: domain exists
    try:
        insert("INSERT INTO repo (domain, repo, comment) VALUES (?, ?, ?)", (domain, repo, comment))
    except GA_IntegrityError:
        raise GA_Exists("Repo already exists")

def db_insert_sshkey(user, algo, key, comment):
    # assumption: user exists
    try:
        insert("INSERT INTO sshkey (user, algo, key, comment) VALUES (user, algo, key, comment)", (user, algo, key, comment))
    except GA_IntegrityError:
        raise GA_Exists("SSH key already exists")

def db_delete_user(user):
    delete("DELETE FROM guest WHERE host = ?", (user,))
    delete("DELETE FROM sshkey WHERE user = ?", (user,))
    delete("DELETE FROM admin WHERE user = ?", (user,))
    delete("DELETE FROM perm WHERE user = ?", (user,))
    if not delete("DELETE FROM user WHERE user = ?", (user,)):
        raise GA_NotFound("User not found")

def db_delete_domain(domain):
    try:
        if not delete("DELETE FROM domain WHERE domain = ?", (domain,)):
            raise GA_NotFound("Domain not found")
    except GA_IntegrityError:
        raise GA_FailedDependencies("Domain not empty")

def db_delete_repo(domain, repo):
    delete("DELETE FROM publicro WHERE domain = ? AND repo = ?", (domain, repo))
    delete("DELETE FROM perm WHERE domain = ? AND repo = ?", (domain, repo))
    if not delete("DELETE FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("Repo not found")

def db_delete_sshkey(user, algo, key):
    if not delete("DELETE FROM sshkey WHERE user = ? AND algo = ? AND key = ?", (user, algo, key)):
        raise GA_NotFound("SSH key not found")

def db_set_admin(domain, user):
    # assumption: domain and user exist
    insert("INSERT OR IGNORE INTO admin (domain, user) VALUES (?, ?)", (domain, user))

def db_clear_admin(domain, user):
    # assumption: domain and user exist
    delete("DELETE FROM admin WHERE domain = ? AND user = ?", (domain, user))

def db_set_perm(domain, repo, user, perm):
    # assumption: domain, repo and user exist. perm = R or RW.
    insert("INSERT OR UPDATE INTO perm (domain, repo, user, perm) VALUES (?, ?, ?, ?)", (domain, repo, user, perm))

def db_clear_perm(domain, repo, user):
    # assumption: domain, repo and user exist.
    delete("DELETE FROM perm WHERE domain = ? AND repo = ? AND user = ?", (domain, repo, user))

def db_set_publicro(domain, repo):
    # assumption: domain and repo exist.
    insert("INSERT OR IGNORE INTO publicro (domain, repo) VALUES (?, ?)", (domain, repo))

def db_clear_publicro(domain, repo):
    # assumption: domain and repo exist.
    delete("DELETE FROM publicro (domain, repo) WHERE domain = ? AND repo = ?", (domain, repo))

def db_set_host(guest, host):
    # assumption: guest and host (both users) exist.
    # there's no corresponding clear routine.
    insert("INSERT OR IGNORE INTO guest (guest, host) VALUES (?, ?)", (guest, host))

# **********************************************************************
# FILESYSTEM LAYER
# **********************************************************************

def fs_initialize():
    mkdir(path_base_dir())
    mkdir(path_repos_dir())
    mkdir(path_publicro_dir())
    write_file(path_authorized_keys(), bytes('', 'UTF-8'))
    create_db()

def fs_make_domain_dir(domain):
    mkdir(path_domain_dir(domain))

def fs_remove_domain_dir(domain):
    rmdir(path_domain_dir(domain))

def fs_create_repo(domain, repo):
    checked_call("git", "init", "--bare", repo_dirpath(domain, repo))

def fs_delete_repo(domain, repo):
    checked_call("rm", "-r", repo_dirpath(domain, repo))

def fs_set_repocomment(domain, repo, comment):
    write_file(path_repocomment(domain, repo), bytes(comment, 'UTF-8'))

def fs_set_publicro_symlink(domain, repo):
    symlink(path_publicro_repo_symlink(domain, repo))

def fs_clear_publicro_symlink(domain, repo):
    unlink(path_publicro_repo_symlink(domain, repo))

# **********************************************************************
# GIT CALLS
# **********************************************************************

def git_send_pack(domain, repo):
    checked_call("git-send-pack", "{}/{}".format(domain, repo))

def git_upload_pack(domain, repo):
    checked_call("git-upload-pack", "{}/{}".format(domain, repo))

# **********************************************************************
# GITADMIN TASKS
# **********************************************************************

def task_info():
    return [commands_listing]

def task_whoami():
    return [(loguser or "(root)") + '\n']

def task_users():
    t = db_list_users()
    return t

def task_domains():
    t = db_list_user_domains(loguser)
    return t

def task_repos(domain):
    t = db_list_domain_repos(domain)
    return t

def task_admins(domain):
    t = db_list_domain_admins(domain)
    return t

def task_perms():
    t = db_list_user_perms(loguser)
    return t

def task_repo_perms(domain, repo):
    t = db_list_repo_perms(domain, repo)
    return t

def task_sshkeys():
    t = db_list_user_sshkeys(loguser)
    return t

def task_guests():
    t = db_list_user_guests(loguser)
    return t

def task_add_sshkey(algo, key, comment):
    db_insert_sshkey(loguser, algo, key, comment)

def task_remove_sshkey(algo, key, comment):
    db_delete_sshkey(algo, key)

def task_create_user(user, comment):
    db_insert_user(user, comment)

def task_delete_user(user):
    db_delete_user(user)

def task_create_guest(guest, comment):
    db_insert_user(guest, comment)
    db_set_host(guest, loguser)

def task_delete_guest(guest):
    db_delete_user(guest)

def task_create_domain(domain, comment):
    db_insert_domain(domain, comment)
    fs_make_domain_dir(domain)

def task_delete_domain(domain):
    db_delete_domain(domain)
    fs_remove_domain_dir(domain)

def task_create_repo(domain, repo, comment):
    db_insert_repo(domain, repo, comment)
    fs_create_repo(domain, repo)

def task_delete_repo(domain, repo):
    db_delete_repo(domain, repo, comment)
    fs_delete_repo(domain, repo)

def task_set_admin(domain, user, admin):
    if admin:
        db_set_admin(domain, user)
    else:
        db_clear_admin(domain, user)

def task_set_public(domain, repo, public):
    if public:
        fs_set_publicro_symlink(domain, repo)
    else:
        fs_clear_publicro_symlink(domain, repo)

def task_su(user, *args):
    global loguser
    global running_su

    assert(loguser is None)
    assert(not running_su)

    loguser = user
    running_su = True
    try:
        exec_cmd_array(user, args)
    finally:
        loguser = None
        running_su = False

# **********************************************************************
# COMMAND VALIDATION AND AUTHENTICATION
# **********************************************************************

# valid_* functions make sure commands are syntactically valid
# If not, GA_Invalid is raised

def valid_info():
    return

def valid_whoami():
    return

def valid_users():
    return

def valid_domains():
    return

def valid_perms():
    return

def valid_sshkeys():
    return

def valid_guests():
    return

def valid_add_sshkey():
    return

def valid_remove_sshkey():
    return

def valid_create_user(user, comment):
    need_valid_username(user)
    need_valid_usercomment(comment)

def valid_delete_user(user):
    need_valid_username(user)

def valid_create_domain(domain, comment):
    need_valid_domainname(domain)
    need_valid_domaincomment(comment)

def valid_delete_domain(domain):
    need_valid_domainname(domain)

def valid_create_repo(domain, repo, comment):
    need_valid_domainname(domain)
    need_valid_reponame(repo)
    need_valid_repocomment(comment)

def valid_delete_repo(domain, repo):
    need_valid_domainname(domain)
    need_valid_reponame(repo)

def valid_set_public(domain, repo, public):
    need_valid_domainname(domain)
    need_valid_reponame(repo)
    need_valid_boolean(public)

def valid_su(user, *args):
    need_valid_username(user)

# auth_* functions make sure commands are authorized
# If not, GA_AuthError is raised

def auth_info():
    return

def auth_whoami():
    return

def auth_users():
    return

def auth_domains():
    return

def auth_perms():
    return

def auth_sshkeys():
    return

def auth_guests():
    return

def auth_add_sshkey():
    return

def auth_remove_sshkey():
    return

def auth_create_user(user, comment):
    require_root_admin()

def auth_delete_user(user):
    require_root_admin()

def auth_create_domain(domain, comment):
    require_root_admin()

def auth_delete_domain(domain):
    require_root_admin()

def auth_create_repo(domain, repo, comment):
    require_domain_admin(domain)

def auth_delete_repo(domain, repo):
    require_domain_admin(domain)

def auth_set_perm(domain, repo, user, perm):
    require_domain_admin(domain)

def auth_set_public(domain, repo, public):
    require_domain_admin(domain)

def auth_su(user, *args):
    require_root_admin()
    require_not_su()

# **********************************************************************
# COMMAND EXECUTION
# **********************************************************************

def exec_cmd_array(user, args):
    global loguser
    global running_su

    if not args:
        return

    auth  = globals().get('auth_'  + args[0])
    valid = globals().get('valid_' + args[0])
    task  = globals().get('task_'  + args[0])

    if auth is None or valid is None or task is None:
        raise GA_Invalid("No such command: " + args[0])

    auth_spec  = inspect.getargspec(auth)
    valid_spec = inspect.getargspec(valid)
    task_spec  = inspect.getargspec(task)

    assert(auth_spec == valid_spec == task_spec)

    if ((task_spec[1] is None and len(args) - 1 != len(task_spec[0])) or
        (task_spec[1] is not None and len(args) - 1 < len(task_spec[0]))):
        raise GA_Invalid("too few or too many arguments. Usage: {} {}".format(args[0], ' '.join(x.upper() for x in task_spec[0])))

    # running_su indicates whether this function is called from task_su(). If it
    # is set, we don't call the transaction functions since DB transactions
    # can't be nested.
    loguser = user
    valid(*args[1:])
    try:
        if not running_su:
            start_db_transaction()
        try:
            auth(*args[1:])
            r = task(*args[1:])
        except:
            abort_db_transaction()
            raise
        else:
            if not running su:
                end_db_transaction()
    finally:
        loguser = None

    for x in list(r or []):
        sys.stdout.write(x)

# **********************************************************************
# COMMAND-LINE SPLITTING AND INTERACTIVE SHELL
# **********************************************************************

def split_cmd_string(cmd_string):
    cmd = ()
    word = ""
    started = False
    quoted = False
    escaped = False
    for char in cmd_string:
        if escaped:
            word += char
            escaped = False
        elif char == '\\':
            escaped = True
            started = True
        elif char == '"':
            quoted = not quoted
            started = True
        elif quoted or char not in ' \t\n\r':
            word += char
            started = True
        elif started:
            cmd = cmd + (word,)
            word = ''
            started = False
    if quoted:
        raise GA_Invalid("Unterminated quote: {}".format(cmd_string))
    if escaped:
        raise GA_Invalid("Trailing escape character: {}".format(cmd_string))
    if started:
        cmd = cmd + (word,)
    return cmd

class GitAdminShell(cmd.Cmd):
    # Sorry to say it, but cmd.Cmd is not a good API

    intro = shell_intro
    prompt = shell_prompt

    def __init__(self, user):
        # Override the bad default to output prompts to sys.stdout.
        # The docs don't hint that the completekey default argument of 'Tab' is
        # really a string (!). Giving None instead doesn't restore the default
        # behaviour but instead disables completion -- but hey, that saved one
        # configuration option.
        super().__init__('Tab', sys.stdin, sys.stderr)

        self.user = user
        if user is None:
            print("Starting root admin shell...", file=sys.stderr)
        else:
            print("Logged in as {}".format(user), file=sys.stderr)

    # We need to override this method because the default is to repeat
    # the last command.
    def emptyline(self):
        pass

    # 'EOF' (a string) is used to indicate that the stdin stream has ended. Not
    # making this up. And why do we need to handle this at all by default?
    def default(self, line):
        if line in ['EOF', 'exit', 'quit']:
            # On EOF, before exiting, end the line which the prompt started.
            if line == 'EOF':
                print('', file=sys.stderr)
            # indicate that the interpreter should be ended
            return True
        else:
            exec_cmd_array(self.user, split_cmd_string(line))

    # We must override this method to be able to handle exceptions from
    # executed commands
    def onecmd(self, line):
        try:
            # All commands should return None, except default() above where we
            # return True for EOF, exit, or quit
            return super().onecmd(line)
        except GA_Exception as e:
            print("ERROR ({}): {}".format(e.msg, str(e)), file=sys.stderr)
            return False

    # We must override this method because keyboard interrupts at the prompt
    # can't be handled in onecmd(). This will cost some stack space, but who
    # cares.
    def cmdloop(self):
        try:
            return super().cmdloop()
        except KeyboardInterrupt as e:
            # start a new line
            print(file=sys.stderr)
            # before looping again, make sure intro won't be displayed again.
            self.intro = None
            return self.cmdloop()

# By default, the built-in do_help command prints a barely useful compilation of
# registered do_* commands. Don't tell anyone what we're doing here!
delattr(cmd.Cmd, 'do_help')


# **********************************************************************
# MAIN
# **********************************************************************

def invoke_help():
    print(long_usage)

def invoke_init():
    fs_initialize()

def invoke_exec_cmdarray(user, cmd_array):
    with_db(exec_cmd_array, user, cmd_array)

def invoke_exec_cmdstring(user, cmd_string):
    with_db(exec_cmd_array, user, split_cmd_string(cmd_string))

def invoke_shell(user):
    if is_stdin_tty and is_stderr_tty:
        shell = GitAdminShell(user)
        with_db(shell.cmdloop)
    else:
        for line in sys.stdin:
            with_db(exec_cmd_array, user, split_cmd_string(line))

def wrong_usage():
    print(help_short, file=sys.stderr)
    sys.exit(1)

def gitadmin(argv, ssh_original_command=None):
    argv = tuple(argv[1:])

    wantinit = None
    wanthelp = None
    req_user = None
    cmd_string = None
    cmd_array = None

    if len(argv) >= 1 and argv[0] == '--init':
        wantinit = ()
        argv = argv[1:]
    if len(argv) >= 1 and argv[0] == '--help':
        wanthelp = ()
        argv = argv[1:]
    if len(argv) >= 2 and argv[0] == '-u':
        req_user = argv[1]
        argv = argv[2:]
    if len(argv) >= 2 and argv[0] == '-c':
        cmd_string = argv[1]
        argv = argv[2:]
    if len(argv) and not argv[0].startswith('-'):
        cmd_array = tuple(argv)
        argv = ()

    if len(argv):
        wrong_usage()

    def exclusive(*opts):
        notnone = [o for o in opts if o is not None]
        if len(notnone) > 1:
            wrong_usage()

    exclusive(wantinit, wanthelp, cmd_array, cmd_string)
    exclusive(wantinit, wanthelp, req_user)

    if wanthelp is not None:
        invoke_help()
    elif wantinit is not None:
        invoke_init()
    elif cmd_array is not None:
        invoke_exec_cmdarray(req_user, cmd_array)
    elif cmd_string is not None:
        invoke_exec_cmdstring(req_user, cmd_string)
    elif ssh_original_command is not None:
        invoke_exec_cmdstring(req_user, ssh_original_command)
    else:
        invoke_shell(req_user)

if __name__ == '__main__':
    gitadmin(sys.argv, os.getenv('SSH_ORIGINAL_COMMAND'))
