#!/usr/bin/env python3

import itertools
import os
import re
import readline, cmd
import sqlite3
import subprocess
import sys

config = {
  'basedir': os.path.join(os.getenv('HOME'), 'basedir'),
  'authorized_keys': os.path.join(os.getenv('HOME'), '.ssh/authorized_keys')
}

short_usage = r"""\
gitadmin invocation:

    gitadmin --help
    gitadmin --init
    gitadmin [-u USER] ARGS...
    gitadmin [-u USER]
    gitadmin [-u USER] -c COMMAND
    SSH_ORIGINAL_CMD=GITCMD gitadmin [-u USER]
"""

long_usage = short_usage + r"""\

Valid gitadmin COMMANDs can be listed with "gitadmin info"

In the first case, print this help message.

In the second case, initialize a new gitadmin environment. gitadmin will abort
if an existing environment is found.

In the third case, the argument list is interpreted as a single gitadmin
command. The arguments must form a pre-split valid gitadmin command. For
example, a valid gitadmin invocation from sh would be

    $ gitadmin create_user john "John Doe"

In the fourth case, run the gitadmin shell interpreter reading commands from
stdin. The shell is run in interactive mode if all standard streams are
connected to a tty, and otherwise in noninteractive mode. If -u USER is given,
run the shell as this gitadmin user. Commands are read line by line, and split
into words with a simple algorithm involving " as quote character and \ as
escape character, similar to the sh quoting algorithm. Example: This\ is" all
one "word. Example gitadmin command line:

    create_repo john testrepo "John's testrepo in the \"john\" domain"

In the fifth case, run the gitadmin shell in noninteractive mode over COMMAND
which must be a single argument. Example gitadmin invocation from sh:

    $ gitadmin -u john -c 'set_perm john testrepo jane RW'

In the sixth case, validate the environment variable SSH_ORIGINAL_CMD as an
allowed git request (git-receive-pack 'DOMAIN/REPO' or git-uploadpack
'DOMAIN/REPO') and execute it.
"""

shell_intro = r"""\
Welcome to gitadmin.

Type 'info' for a list of available commands
"""

shell_prompt = 'gitadmin> '

shell_usage = r"""\
Root admin commands:

   users
   su USER CMD...
   create_domain DOMAIN COMMENT
   delete_domain DOMAIN
   create_user USER COMMENT
   delete_user USER

Domain admin commands:

  admins DOMAIN
  repos DOMAIN                              User commands:
  repo_perms DOMAIN REPO
  set_domain_admin DOMAIN USER                info
  unset_domain_admin DOMAIN USER              whoami
  create_repo DOMAIN REPO COMMENT             domains
  delete_repo DOMAIN REPO                     perms
  set_repo_comment DOMAIN REPO COMMENT        sshkeys
  set_perm DOMAIN REPO USER <none|R|RW>       add_sshkey
  set_public DOMAIN REPO <true|false>         remove_sshkey
"""

authorized_keys_header = r"""\
#
# THIS FILE IS MANAGED BY GITADMIN
#
"""

sqlschema = r"""
CREATE TABLE domain
( id INTEGER PRIMARY KEY
, name VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, UNIQUE (name)
);

CREATE TABLE user
( id INTEGER PRIMARY KEY
, name VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, UNIQUE (name)
);

CREATE TABLE repo
( id INTEGER PRIMARY KEY
, domainid INTEGER NOT NULL
, name VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, FOREIGN KEY (domainid) REFERENCES domain(id)
, UNIQUE (domainid, name)
);

CREATE TABLE permissions
( repoid INTEGER NOT NULL
, userid INTEGER NOT NULL
, mode INTEGER NOT NULL  -- 0 or 1 (R or RW)
--
, FOREIGN KEY (repoid) REFERENCES repo(id)
, FOREIGN KEY (userid) REFERENCES user(id)
, UNIQUE (repoid, userid)
);

CREATE TABLE admin
( domainid INTEGER NOT NULL
, userid INTEGER NOT NULL
--
, FOREIGN KEY (domainid) REFERENCES domain(id)
, FOREIGN KEY (userid) REFERENCES user(id)
, UNIQUE (domainid, userid)
);

CREATE TABLE sshkey
( id INTEGER PRIMARY KEY
, userid INTEGER NOT NULL
, algo VARCHAR NOT NULL
, key VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, FOREIGN KEY (userid) REFERENCES user(id)
, UNIQUE (key)
);

CREATE TABLE publicro
( repoid INTEGER NOT NULL UNIQUE
--
, FOREIGN KEY (repoid) REFERENCES repo(id)
);

INSERT INTO user (id, name, comment) VALUES (0, "root", "");
"""

domainname_regex = r"""[abcdefghijklmnopqrstuvwxyz]{2,16}"""
username_regex   = r"""[abcdefghijklmnopqrstuvwxyz0123456789]{2,16}"""
reponame_regex   = r"""[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-]{2,32}"""
domaincomment_regex = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
usercomment_regex   = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"#$%&'()*+../:;<=>@?[\^_`{|}~-]{0,255}"""
repocomment_regex   = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
algo_regex    = r"""(?:ssh-ed25519|ssh-rsa|ssh-dss|ecdsa-sha2-nistp256|ecdsa-sha2-nistp384|ecdsa-sha2-nistp521)"""
key_regex     = r"""[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/]{32,8192}={0,2}"""
comment_regex = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""

# filled later when functions are defined
dfl_cmds = {}
user_cmds = {}
domain_cmds = {}
root_cmds = {}

# constants (after this initialization)
is_stdin_tty = os.isatty(sys.stdin.fileno())
is_stdout_tty = os.isatty(sys.stdout.fileno())
is_stderr_tty = os.isatty(sys.stderr.fileno())
# this will remain constant after initialization in main()
is_interactive = None
# these are set when the database connection is made
# (=> not for --help and --init run modes)
# They remain constant once set, except they might be temporarily swapped by
# "su"
loguser = None
loguid = None
is_root = False
stored_loguser = None
stored_loguid = None
# database connection
conn = None

class GAError(Exception):
    """Expected error conditions in gitadmin"""
    pass

class InvalidArgument(GAError):
    def __str__(self):
        return "Invalid Argument: {}".format(*self.args)

class Unauthorized(GAError):
    def __str__(self):
        return "Permission denied: {}".format(*self.args)

class GitAdminShell(cmd.Cmd):
    def __init__(self, intro='', prompt=''):
        super().__init__()

    def emptyline(self):
        pass

    def default(self, line):
        if line == 'EOF':
            print()
            sys.exit(0)
        else:
            raise InvalidArgument("Couldn't parse command")

    def onecmd(self, line):
        try:
            super().onecmd(line)
        except GAError as e:
            print("ERROR:", e, file=sys.stderr)

    def cmdloop(self):
        try:
            super().cmdloop()
        except KeyboardInterrupt as e:
            print()
            self.intro = None  # HACK
            self.cmdloop()

    intro = shell_intro
    prompt = shell_prompt

def basedir_filepath():
    return config['basedir']

def authorized_keys_filepath():
    return config['authorized_keys']

def database_filepath():
    base = basedir_filepath()
    return os.path.join(base, 'gitadmin.sqlite3')

def repos_dirpath():
    base = basedir_filepath()
    return os.path.join(base, 'repos')

def domain_dirpath(domain):
    base = repos_dirpath()
    return os.path.join(base, domain)

def repo_dirpath(domain, repo):
    dirpath = domain_dirpath(domain)
    return os.path.join(dirpath, repo) + '.git'

def repo_comment_filepath(domain, repo):
    dirpath = repo_dirpath(domain, repo)
    return os.path.join(dirpath, 'description')

def publicro_dirpath():
    dirpath = basedir_filepath()
    return os.path.join(dirpath, 'publicro')

def publicro_domain_dirpath(domain):
    dirpath = publicro_dirpath()
    return os.path.join(dirpath, domain)

def publicro_repo_dirpath(domain, repo):
    dirpath = publicro_domain_dirpath(domain)
    return os.path.join(dirpath, repo)

def connect_database():
    global conn
    dbpath = database_filepath()
    if not os.path.isfile(dbpath):
        raise GAError("Database doesn't exist. Call 'gitadmin --init'")
    conn = sqlite3.connect(dbpath)
    conn.isolation_level = None
    conn.execute("PRAGMA FOREIGN_KEYS = ON")

def disconnect_database():
    global conn
    conn.close()
    conn = None

def create_database():
    dbpath = database_filepath()
    c = sqlite3.connect(dbpath)
    c.isolation_level = None
    c.execute("PRAGMA FOREIGN_KEYS = ON")
    c.executescript(sqlschema)
    c.close()

def create_authorized_keys():
    path = authorized_keys_filepath()
    f = open(path, 'w')
    f.write(authorized_keys_header)
    f.close()

def replace_ssh_authorized_keys(contents):
    fpath = authorized_keys_filepath()
    tmp = fpath + ".tmp"
    f = open(tmp, 'w')
    f.write(authorized_keys_header + contents)
    f.close()
    os.rename(tmp, fpath)

def create_repos_dir():
    dirpath = repos_dirpath()
    os.mkdir(dirpath)

def create_publicro_dir():
    dirpath = publicro_dirpath()
    os.mkdir(dirpath)

def create_domain_dir(domain):
    dirpath = domain_dirpath(domain)
    os.mkdir(dirpath)

def delete_domain_dir(domain):
    dirpath = domain_dirpath(domain)
    os.rmdir(dirpath)

def create_repo_git(domain, reponame):
    path = repo_dirpath(domain, reponame)
    subprocess.call(["git", "init", "--bare", path])

def delete_repo_git(domain, reponame):
    path = repo_dirpath(domain, reponame)
    subprocess.call(["rm", "-rf", "--", path])

def set_repo_comment_git(domain, repo, comment):
    path = repo_comment_filepath(domain, repo)
    open(path, "w").write(comment)

def create_publicro_domain_dir(domain):
    dirpath = publicro_domain_dirpath(domain)
    os.mkdir(dirpath)

def delete_publicro_domain_dir(domain):
    dirpath = publicro_domain_dirpath(domain)
    os.rmdir(dirpath)

def update_publicro_symlink(domain, repo, publish):
    dirpath = repo_dirpath(domain, repo)
    linkpath = publicro_repo_dirpath(domain, repo)
    if publish:
        try:
            os.symlink(dirpath, linkpath)
        except OSError as e:
            raise GAError('Failed to create symlink: {}'.format(e))
    else:
        try:
            os.unlink(linkpath)
        except OSError as e:
            raise GAError('Failed to remove symlink: {}'.format(e))

def exact_match(regex, x):
    return re.match(r'^' + regex + r'$', x)

def need_valid_domainname(x):
    if not exact_match(domainname_regex, x):
        raise InvalidArgument("'{}' is not a valid domain name".format(x))

def need_valid_domaincomment(x):
    if not exact_match(domaincomment_regex, x):
        raise InvalidArgument("'{}' is not a valid domain comment".format(x))

def need_valid_username(x):
    if not exact_match(username_regex, x):
        raise InvalidArgument("'{}' is not a valid user name".format(x))

def need_valid_usercomment(x):
    if not exact_match(usercomment_regex, x):
        raise InvalidArgument("'{}' is not a valid user comment".format(x))

def need_valid_reponame(x):
    if not exact_match(reponame_regex, x):
        raise InvalidArgument("'{}' is not a valid repo name".format(x))

def need_valid_repocomment(x):
    if not exact_match(repocomment_regex, x):
        raise InvalidArgument("'{}' is not a valid repo comment".format(x))

def need_valid_algo(x):
    if not exact_match(algo_regex, x):
        raise InvalidArgument("'{}' is not a valid SSH key algo".format(x))

def need_valid_key(x):
    if not exact_match(key_regex, x):
        raise InvalidArgument("'{}' is not a valid SSH key".format(x))

def need_valid_comment(x):
    if not exact_match(comment_regex, x):
        raise InvalidArgument("'{}' is not a valid SSH key comment".format(x))

def need_valid_sshkey(x):
    regex = r'({}) +({})(?: +({}))?'.format(
        algo_regex, key_regex, comment_regex
    )
    m = exact_match(regex, x)
    if m is None:
        raise InvalidArgument("Sorry, I couldn't parse the ssh key")
    x, y, z = m.groups()
    return x, y, (z or "")

def need_domain_id(domain):
    need_valid_domainname(domain)
    rs = conn.execute("SELECT id FROM domain WHERE name = ?", (domain,))
    rs = list(rs)
    if not rs:
        raise GAError("domain does not exist: {}".format(domain))
    return rs[0][0]

def need_user_id(user):
    need_valid_username(user)
    rs = conn.execute("SELECT id FROM user WHERE name = ?", (user,))
    rs = list(rs)
    if not rs:
        raise GAError("user does not exist: {}".format(user))
    return rs[0][0]

def need_repo_id(domain, repo):
    need_valid_reponame(repo)
    rs = conn.execute("""SELECT R.id
                         FROM repo R JOIN domain D ON R.domainid = D.id
                         WHERE R.name = ? AND D.name = ?""", (repo, domain))
    rs = list(rs)
    if not rs:
        raise GAError("repo does not exist: {}/{}".format(domain, repo))
    return rs[0][0]

def need_is_root():
    if not is_root:
        raise Unauthorized("You are not root admin")

def need_is_domain_admin(domain):
    domainid = need_domain_id(domain)
    if is_root:
        return
    rs = conn.execute("""SELECT 1 FROM admin A
                         WHERE A.domainid = ? AND A.userid = ?""",
                      (domainid, loguid))
    rs = list(rs)
    if not rs:
        raise Unauthorized("You are not admin of {}".format(domain))

def need_read_permission(domain, repo):
    repoid = need_repo_id(domain, repo)
    rs = conn.execute("""SELECT 1 FROM permissions P
                         WHERE P.repoid = ? AND P.userid = ?""",
                      (repoid, loguid))
    rs = list(rs)
    if not rs:
        raise Unauthorized("You don't have permission to read from {}/{}"
                           .format(domain, repo))

def need_write_permission(domain, repo):
    repoid = need_repo_id(domain, repo)
    rs = conn.execute("""SELECT 1 FROM permissions P
                         WHERE P.repoid = ? AND P.userid = ? AND P.mode = 1""",
                      (repoid, loguid))
    rs = list(rs)
    if not rs:
        raise Unauthorized("You don't have permission to write to {}/{}"
                           .format(domain, repo))

def warn_unadministered_domains():
    rs = conn.execute("""SELECT D.name FROM domain D
                         WHERE NOT EXISTS (SELECT 1 FROM admin A WHERE D.id = A.domainid)
                         ORDER BY D.name""")
    for r in rs:
        print("WARNING: Domain has no admin: {}".format(r[0]), file=sys.stderr)

def split_cmdline(cmdline):
    cmd = []
    word = ""
    started = False
    quoted = False
    escaped = False
    for char in cmdline:
        if escaped:
            word += char
            started = True
            escaped = False
        elif char == '\\':
            escaped = True
        elif char == '"':
            quoted = not quoted
            started = True
        # XXX: .isspace() supports locales. Good thing?
        elif char.isspace() and not quoted:
            if started:
                cmd.append(word)
            word = ""
            started = False
        else:
            word += char
            started = True
    if quoted:
        raise InvalidArgument("Unterminated quote: {}".format(cmdline))
    if escaped:
        raise InvalidArgument("Trailing escape character: {}".format(cmdline))
    if started:
        cmd.append(word)
    return cmd

def format_authorized_keys_line(user, algo, key, comment):
    return ("""command="gitadmin -u {}" {} {} {}\n"""
            .format(user, algo, key, comment))

def format_authorized_keys(rs):
    lines = [format_authorized_keys_line(*r) for r in rs]
    return authorized_keys_header + ''.join(lines)

def format_table(rs):
    """Formats a list of lists of things nicely for the user
    Returns a list of strings (the rows formatted with matching colum widths)
    """
    lensll = [[len(c) for c in r] for r in rs]
    lensll = itertools.zip_longest(*lensll, fillvalue=0)
    collens = [max(lens) for lens in lensll]
    out = []
    def lalign(s, n):
        return s + (" " * (n - len(s)))
    for r in rs:
        fmtr = [lalign(str(c), l) for c, l in zip(r, collens)]
        out.append('\t'.join(fmtr))
    return out

def print_table(rs):
    rs = list(rs)
    if is_interactive:
        for r in format_table(rs):
            print(r)
    else:
        for r in rs:
            print('\t'.join(str(c) for c in r))

def update_ssh_authorized_keys():
    rs = conn.execute("""SELECT U.name, S.algo, S.key, S.comment
                         FROM user U JOIN sshkey S ON U.id = S.userid""")
    cts = format_authorized_keys(rs)
    replace_ssh_authorized_keys(cts)

def transaction(cmd):
    def func(*args, **kwargs):
        conn.execute("BEGIN TRANSACTION")
        try:
            try:
                r = cmd(*args, **kwargs)
            except sqlite3.IntegrityError as e:
                # TODO: Ensure all expected database error conditions are
                # handled locally, and leave this error a non-GAError
                raise GAError(
                    "The database issued an integrity constraint error. "
                    "If you tried to delete data, that probably means that "
                    "there are leftover dependencies. "
                    "If you tried to input data, that probably means that "
                    "such an entry already exists. The database error was: {}"
                    .format(e))
        except:
            conn.execute("ROLLBACK")
            raise
        conn.execute("COMMIT")
        return r
    return func

def install_docmd(cmd):
    def func(self, x):
        return exec_cmdline('{} {}'.format(cmd.__name__, x))
    setattr(GitAdminShell, 'do_' + cmd.__name__, func)

def sucmd(cmd):
    install_docmd(cmd)
    def func(*args, **kwargs):
        need_is_root()
        return cmd(*args, **kwargs)
    root_cmds[cmd.__name__] = func

def rootcmd(cmd):
    install_docmd(cmd)
    @transaction
    def func(*args, **kwargs):
        need_is_root()
        return cmd(*args, **kwargs)
    root_cmds[cmd.__name__] = func

def domaincmd(cmd):
    install_docmd(cmd)
    @transaction
    def func(domain, *args, **kwargs):
        need_domain_id(domain)
        need_is_domain_admin(domain)
        return cmd(domain, *args, **kwargs)
    domain_cmds[cmd.__name__] = func

def usercmd(cmd):
    install_docmd(cmd)
    @transaction
    def func(*args, **kwargs):
        return cmd(*args, **kwargs)
    user_cmds[cmd.__name__] = func

def dflcmd(cmd):
    install_docmd(cmd)
    @transaction
    def func(*args, **kwargs):
        return cmd(*args, **kwargs)
    user_cmds[cmd.__name__] = func

@dflcmd
def info():
    print(shell_usage)

@usercmd
def whoami():
    print(loguser)

@usercmd
def domains():
    if is_root:
        rs = conn.execute("""SELECT D.name, D.comment FROM domain D
                             ORDER BY D.name""")
    else:
        rs = conn.execute("""SELECT D.name, D.comment
                             FROM domain D JOIN Admin A ON D.id = A.domainid
                             WHERE A.userid = ?
                             ORDER BY D.name""", (loguid,))
    print_table(rs)

@usercmd
def perms():
    rs = conn.execute("""
        SELECT D.name, R.name, U.name, CASE WHEN P.mode=0 THEN "R" ELSE "RW" END
        FROM domain D
             JOIN repo R ON D.id = R.domainid
             JOIN permissions P on R.id = P.repoid
             JOIN user U on P.userid = U.id
        WHERE U.id = ?
        ORDER BY D.name, R.name""", (loguid,))
    print_table(rs)

@usercmd
def sshkeys():
    rs = conn.execute("""SELECT S.algo, S.key, S.comment
                         FROM sshkey S WHERE S.userid = ?""", (loguid,))
    for r in rs:
        print(' '.join(r))

@usercmd
def add_sshkey():
    if is_root:
        raise GAError("You are the root admin; refusing to add an SSH key")
    if is_interactive:
        print("Please give the key which you want added on one line",
              file=sys.stderr)
    line = sys.stdin.readline()
    algo, key, comment = need_valid_sshkey(line)
    try:
        conn.execute("""INSERT INTO sshkey (userid, algo, key, comment)
                        VALUES (?, ?, ?, ?)""", (loguid, algo, key, comment))
    except sqlite3.IntegrityError as e:
        raise GAError("This key is already in the database")  # or user deleted
    else:
        update_ssh_authorized_keys()

@usercmd
def remove_sshkey():
    if is_interactive:
        print("Please give the key which you want removed on one line, "
              "just as returned by 'sshkeys'", file=sys.stderr)
    line = sys.stdin.readline()
    algo, key, _ = need_valid_sshkey(line)
    conn.execute("""DELETE FROM sshkey
                    WHERE userid = ? AND key = ?""", (loguid, key))
    rs = conn.execute("SELECT changes()")
    rs = list(rs)
    if rs[0][0]:
        update_ssh_authorized_keys()
    else:
        print("WARNING: Key not found", file=sys.stderr)

@domaincmd
def admins(domain):
    domainid = need_domain_id(domain)
    rs = conn.execute("""
        SELECT D.name, U.name
        FROM admin A
             JOIN domain D ON A.domainid = D.id
             JOIN user U ON A.userid = U.id
        WHERE D.id = ?
        ORDER BY U.name""", (domainid,))
    print_table(rs)

@domaincmd
def repos(domain):
    domainid = need_domain_id(domain)
    rs = conn.execute("""SELECT R.name, R.comment FROM repo R
                         WHERE R.domainid = ? ORDER BY R.name""", (domainid,))
    print_table(rs)

@domaincmd
def repo_perms(domain, repo):
    domainid = need_domain_id(domain)
    repoid = need_repo_id(domain, repo)
    rs = conn.execute("""
        SELECT D.name, R.name, U.name, CASE WHEN P.mode=0 THEN "R" ELSE "RW" END
        FROM domain D
             JOIN repo R ON D.id = R.domainid
             JOIN permissions P ON R.id = P.repoid
             JOIN user U ON P.userid = U.id
        WHERE R.id = ?
        ORDER BY U.name""", (repoid,))
    print_table(rs)

@domaincmd
def create_repo(domain, repo, comment):
    domainid = need_domain_id(domain)
    need_valid_reponame(repo)
    need_valid_repocomment(comment)
    try:
        conn.execute("""INSERT INTO repo (domainid, name, comment)
                        VALUES (?, ?, ?)""", (domainid, repo, comment))
    except sqlite3.IntegrityError:
        raise GAError("Repo exists: {}".format(repo))
    create_repo_git(domain, repo)
    set_repo_comment_git(domain, repo, comment)

@domaincmd
def delete_repo(domain, repo):
    repoid = need_repo_id(domain, repo)
    conn.execute("DELETE FROM publicro WHERE repoid = ?", (repoid,))
    conn.execute("DELETE FROM permissions WHERE repoid = ?", (repoid,))
    conn.execute("DELETE FROM repo WHERE id = ?", (repoid,))
    delete_repo_git(domain, repo)

@domaincmd
def set_repo_comment(domain, repo, comment):
    repoid = need_repo_id(domain, repo)
    need_valid_repocomment(comment)
    conn.execute("UPDATE repo SET comment = ? WHERE id = ?", (comment, repoid))
    set_repo_comment_git(domain, repo, comment)

@domaincmd
def set_domain_admin(domain, user):
    domainid = need_domain_id(domain)
    userid = need_user_id(user)
    if user == "root":
        print("No need to make the root admin a domain admin", file=sys.stderr)
    else:
        conn.execute("""INSERT OR IGNORE INTO admin (domainid, userid)
                        VALUES (?, ?)""", (domainid, userid))

@domaincmd
def unset_domain_admin(domain, user):
    domainid = need_domain_id(domain)
    userid = need_user_id(user)
    conn.execute("DELETE FROM admin WHERE domainid = ? AND userid = ?",
                 (domainid, userid))

@domaincmd
def set_perm(domain, repo, user, perm):
    repoid = need_repo_id(domain, repo)
    userid = need_user_id(user)
    mode = { "none": -1, "R": 0, "RW": 1 }.get(perm)
    if mode is None:
        raise InvalidArgument("Permissions must be one of none, R or RW")
    if user == "root":
        print("No need to add permissions for the root admin", file=sys.stderr)
    elif mode == -1:
        conn.execute("""DELETE FROM permissions
                        WHERE repoid = ? AND userid = ?""", (repoid, userid))
    else:
        conn.execute("""INSERT OR REPLACE INTO permissions (repoid,userid,mode)
                        VALUES (?, ?, ?)""", (repoid, userid, mode))

@domaincmd
def set_public(domain, repo, boolean):
    repoid = need_repo_id(domain, repo)
    publish = { 'true': True, 'false': False }.get(boolean)
    if publish is None:
        raise InvalidArgument("Usage: set_public <DOMAIN> <REPO> <true|false>")
    if publish:
        conn.execute("""INSERT OR IGNORE INTO publicro (repoid)
                        VALUES (?)""", (repoid,))
    else:
        conn.execute("DELETE FROM publicro WHERE repoid = ?", (repoid,))
    rs = conn.execute("SELECT changes()")
    rs = list(rs)
    if rs[0][0] != 0:
        update_publicro_symlink(domain, repo, publish)

@rootcmd
def users():
    rs = conn.execute("""SELECT U.name, U.comment FROM user U
                         WHERE U.name <> "root" """)
    print_table(rs)

@sucmd
def su(user, *args):
    userid = need_user_id(user)
    global loguser
    global loguid
    global is_root
    global stored_loguser
    global stored_loguid
    stored_loguser = loguser
    stored_loguid = loguid
    loguser = user
    loguid = userid
    is_root = loguser == "root"
    try:
        exec_cmd_array(args)
    finally:
        loguser = stored_loguser
        loguid = stored_loguid
        is_root = loguser == "root"

@rootcmd
def create_domain(domain, comment):
    need_valid_domainname(domain)
    need_valid_domaincomment(comment)
    try:
        conn.execute("""INSERT INTO domain (name, comment)
                        VALUES (?, ?)""", (domain, comment))
    except sqlite3.IntegrityError:
        raise GAError("Domain exists: {}".format(domain))
    create_domain_dir(domain)
    create_publicro_domain_dir(domain)

@rootcmd
def delete_domain(domain):
    domainid = need_domain_id(domain)
    conn.execute("DELETE FROM admin WHERE domainid = ?", (domainid,))
    try:
        conn.execute("DELETE FROM domain WHERE id = ?", (domainid,))
    except sqlite3.IntegrityError as e:
        raise GAError("Can't delete domain since it contains repositories")
    delete_domain_dir(domain)
    delete_publicro_domain_dir(domain)

@rootcmd
def create_user(user, comment):
    need_valid_username(user)
    need_valid_usercomment(comment)
    try:
        conn.execute("""INSERT INTO user (name, comment)
                        VALUES (?, ?)""", (user, comment))
    except sqlite3.IntegrityError:
        raise GAError("User exists: {}".format(user))

@rootcmd
def delete_user(user):
    userid = need_user_id(user)
    if (user == "root"):
        print("WARNING: Refusing to delete root user", file=sys.stderr)
        return
    conn.execute("DELETE FROM sshkey WHERE userid = ?", (userid,))
    conn.execute("DELETE FROM admin WHERE userid = ?", (userid,))
    conn.execute("DELETE FROM permissions WHERE userid = ?", (userid,))
    conn.execute("DELETE FROM user WHERE id = ?", (userid,))
    warn_unadministered_domains()
    update_ssh_authorized_keys()

def git_receive_pack(domain, repo):
    need_write_permission(domain, repo)
    path = repo_dirpath(domain, repo)
    subprocess.call(['git-receive-pack', path])

def git_upload_pack(domain, repo):
    need_read_permission(domain, repo)
    path = repo_dirpath(domain, repo)
    subprocess.call(['git-upload-pack', path])

def exec_cmd_array(cmd):
    name, arguments = cmd[0], cmd[1:]
    if name in root_cmds:
        func = root_cmds[name]
    elif name in domain_cmds:
        func = domain_cmds[name]
    elif name in user_cmds:
        func = user_cmds[name]
    else:
        raise InvalidArgument("No such command: {}".format(name))
    try:
        func(*arguments)
    except TypeError:
        # for now, let's hope this is true
        # using inspection before calling func would be overkill
        raise InvalidArgument("wrong number of arguments: {}".format(name))

def exec_cmdline(cmdline):
    cmd_array = split_cmdline(cmdline)
    if cmd_array:
        return exec_cmd_array(cmd_array)

def exec_git_cmdline(ssh_original_command):
    # probably git-* will recognize 8bit unclean streams themselves...
    #need_8bitclean()
    regex = r"({}|{}) '({})/({})'".format(
        'git-receive-pack', 'git-upload-pack', domainname_regex, reponame_regex)
    m = exact_match(regex, ssh_original_command)
    if m is None:
        raise InvalidArgument(
            "Invalid command: {}\n"
            "Only\n"
            "\tgit-receive-pack 'DOMAIN/REPO'\n"
            "\tgit-upload-pack  'DOMAIN/REPO'\n"
            "are allowed commands (DOMAIN and REPO must be valid names)."
            .format(ssh_original_command)
        )
    cmd, domain, repo = m.groups()
    if cmd == 'git-receive-pack':
       git_receive_pack(domain, repo)
    elif cmd == 'git-upload-pack':
       git_upload_pack(domain, repo)

def initialize_gitadmin_environment():
    basedir_exists = os.path.isdir(basedir_filepath())
    basedir_empty = not basedir_exists or not os.listdir(basedir_filepath())
    database_exists = os.path.isfile(database_filepath())
    authorized_keys_exists = os.path.isfile(authorized_keys_filepath())
    if not basedir_exists or not basedir_empty:
        raise GAError('The basedir {} does not exist or is not empty. '
                      'Refusing to initialize'.format(basedir_filepath()))
    if authorized_keys_exists:
        raise GAError('authorized_keys file {} exists. Refusing to initialize'
                      .format(authorized_keys_filepath()))
    if database_exists:
        raise GAError('Database {} exists. Refusing to initialize.'
                      .format(database_filepath()))
    create_repos_dir()
    create_publicro_dir()
    create_authorized_keys()
    create_database()

def run_cmdstring_shell(cmdstring):
    for line in cmdstring.splitlines():
        exec_cmdline(line)

def run_interactive_stdin_shell():
    assert(is_interactive)
    if is_root:
        print("Starting root admin shell...")
    GitAdminShell().cmdloop()

def run_noninteractive_stdin_shell():
    assert(not is_interactive)
    for line in sys.stdin:
        exec_cmdline(line)

def login_user(user):
    global loguser
    global loguid
    global is_root
    loguser = "root"
    loguid = 0
    loguid = need_user_id(user)
    loguser = user
    is_root = loguser == "root"

def need_dbconn(cmd):
    def func(req_user, *args, **kwargs):
        connect_database()
        if req_user is None:
            login_user("root")
        else:
            login_user(req_user)
        try:
            r = cmd(*args, **kwargs)
        finally:
            disconnect_database()
        return r
    return func

def process_help_request():
    global is_interactive
    is_interactive = False
    print(long_usage)

def process_init_request():
    global is_interactive
    is_interactive = False
    initialize_gitadmin_environment()

@need_dbconn
def process_cmd_array(cmd_array):
    global is_interactive
    # other shells test only stdin and stderr. But Cmd.cmd prints prompts to
    # stdout instead of stderr (can we fix that?), so for example, after
    # "x=$(gitadmin whoami)" x contains not only a username but also the
    # prompts. For this reason we test also whether stdout is a tty, to run a
    # noninteractive shell if we are being run inside a command substitution.
    is_interactive = is_stdin_tty and is_stdout_tty and is_stderr_tty
    exec_cmd_array(cmd_array)

@need_dbconn
def process_cmd_string(cmd_string):
    global is_interactive
    is_interactive = False
    run_cmdstring_shell(cmd_string)

@need_dbconn
def process_stdin():
    global is_interactive
    # the same as in process_cmd_array() applies for this decision
    is_interactive = is_stdin_tty and is_stdout_tty and is_stderr_tty
    if is_interactive:
        run_interactive_stdin_shell()
    else:
        run_noninteractive_stdin_shell()

@need_dbconn
def process_ssh_original_command(ssh_original_command):
    global is_interactive
    # currently only git supported
    exec_git_cmdline(ssh_original_command)

def gitadmin(argv, ssh_original_command):
    argv = argv[1:]
    wantinit = None
    wanthelp = None
    req_user = None
    cmd_string = None
    cmd_array = None
    if len(argv) >= 1 and argv[0] == '--init':
        wantinit = ()
        argv = argv[1:]
    if len(argv) >= 1 and argv[0] == '--help':
        wanthelp = ()
        argv = argv[1:]
    if len(argv) >= 2 and argv[0] == '-u':
        req_user = argv[1]
        argv = argv[2:]
    if len(argv) >= 2 and argv[0] == '-c':
        cmd_string = argv[1]
        argv = argv[2:]
    if len(argv) and not argv[0].startswith('-'):
        cmd_array = list(argv)
        argv = []

    def wrong_usage():
        print(short_usage, file=sys.stderr)
        sys.exit(1)
    def exclusive(*opts):
        notnone = [o for o in opts if o is not None]
        if len(notnone) > 1:
            wrong_usage()
    if len(argv):
        wrong_usage()
    exclusive(wantinit, wanthelp, cmd_array, cmd_string)
    exclusive(wantinit, wanthelp, req_user)

    if wanthelp is not None:
        process_help_request()
    elif wantinit is not None:
        process_init_request()
    elif cmd_array is not None:
        process_cmd_array(req_user, cmd_array)
    elif cmd_string is not None:
        process_cmd_string(req_user, cmd_string)
    elif ssh_original_command is None:
        process_stdin(req_user)
    else:
        process_ssh_original_command(req_user, ssh_original_command)

def main(argv, ssh_original_command=None):
    try:
        gitadmin(argv, ssh_original_command)
    except GAError as e:
        print("gitadmin:", e, file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print("gitadmin: Unexpected error:", e, file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("Keyboard interrupt", file=sys.stderr)

if __name__ == '__main__':
    main(sys.argv, os.getenv('SSH_ORIGINAL_COMMAND'))
