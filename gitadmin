#!/usr/bin/python3

#
# gitadmin - Copyright (c) 2015, Jens Stimpfle
#
# Find invocation instructions below
# and documentation throughout the code
#

import os, sys, re
import shlex
import sqlite3
import inspect
import readline, cmd

is_stdin_tty  = os.isatty(sys.stdin.fileno())
is_stdout_tty = os.isatty(sys.stdout.fileno())
is_stderr_tty = os.isatty(sys.stderr.fileno())


# *****************************************************************************
# CONFIG
# *****************************************************************************

config_basedir = 'gitadmin-basedir'

# These regexen can be tweaked, but additionally the following assumptions
# will be checked for any value that goes in the DB:
#
# - repos and domains need to be valid filepath components (not "." or "..",
#   does not contain "/" or "\"
# - other than comments which are always printed in the last column, no
#   whitespace allowed (which would prohibit scripting)
# - multiple lines not allowed (currently check for \r and \n)
#
# Warning: user names go to the authorized_keys file. Dangerous!
# There may be other, undocumented assumptions. It's probably unwise to allow
# shell special characters in non-comment data.
#
# as per the python3 documentation, character classes ([a-z] etc) are ASCII
username_regex    = r"""[a-z][a-z0-9]{1,15}"""
domainname_regex  = r"""[a-z][a-z0-9]{1,15}"""
reponame_regex    = r"""[a-zA-Z][a-zA-Z0-9_-]{1,15}"""
sshkey_algo_regex = r"""(?:ssh-ed25519|ssh-rsa|ssh-dss|ecdsa-sha2-nistp256|ecdsa-sha2-nistp384|ecdsa-sha2-nistp521)"""
sshkey_key_regex  = r"""[a-zA-Z0-9+/]{32,8192}={0,2}"""
userdesc_regex    = r"""[]a-zA-Z0-9 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
domaindesc_regex  = r"""[]a-zA-Z0-9 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
repodesc_regex    = r"""[]a-zA-Z0-9 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
sshkeydesc_regex  = r"""[]a-zA-Z0-9 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""


# *****************************************************************************
# GLOBAL STATE
# *****************************************************************************

# (effective) gitadmin user
loguser = None

# DB connection
conn = None


# *****************************************************************************
# STRINGS
# *****************************************************************************

help_short = r"""
gitadmin invocation:

    gitadmin --help
    gitadmin --init
    gitadmin [-u USER] ARGS...
    gitadmin [-u USER] -c CMD
    gitadmin [-u USER]
    SSH_ORIGINAL_CMD=GITCMD gitadmin [-u USER]
"""

help_long = help_short + r"""
gitadmin --help

    Print this help message.

gitadmin --init

    Initialize a new gitadmin environment. gitadmin aborts if an
    existing environment is found. The base directory 'gitadmin-basedir'
    (or whatever was configured by changing the program code) must
    exist, and be empty.  Filepath customization is currently done
    after initialization by moving the objects which were created in
    the base directory somewhere else, and putting symlinks into the
    base directory.

gitadmin [-u USER] ARGS...

    The argument list ARGS is interpreted as a (pre-split) gitadmin
    command (possible commands are listed by the `info' command). If
    -u USER is given, interpret the command as this gitadmin user.
    For example, a valid invocation from the shell (sh) would be

        $ gitadmin create_user john "John Doe"

gitadmin [-u USER] -c CMD

    In the fourth case, run the gitadmin shell in noninteractive mode,
    interpreting CMD which must be a gitadmin shell command (a single
    argument). The gitadmin shell syntax is explained a little in the
    next paragraph. If -u USER is given, run as the given gitadmin
    user. Example gitadmin invocation from sh:

        $ gitadmin -u john -c 'set_perm john testrepo jane RW'

gitadmin [-u USER]

    Run the gitadmin shell, interpreting commands read from stdin.
    If standard input and standard error are both connected to ttys, an
    interactive with command-line editing and (session) history is run.
    If -u USER is given, run the shell as this gitadmin user. Commands
    are read line by line, and split into words with a simple algorithm
    involving quotation mark (") as quote character and backslash (\)
    as escape character, similar to the quoting algorithm known from
    sh. Example: This\ is" all one "word.

    Example gitadmin commands:

        gitadmin> create_repo john testrepo "John's repo, in domain \"john\""
        gitadmin> set_perm john testrepo john RW
        gitadmin> set_perm john testrepo jane R

    (The `gitadmin> ' prompts are printed by gitadmin in interactive mode,
    to indicate that it is waiting for the next command).

SSH_ORIGINAL_CMD=GITCMD gitadmin [-u USER]

    Validate the environment variable SSH_ORIGINAL_CMD as an allowed
    git request (git-upload-pack 'DOMAIN/REPO' or git-receive-pack
    'DOMAIN/REPO', as can be observed with the git reference
    implementation) and execute it as a subprocess if the requesting user
    has appropriate permission.  This allows the actual git traffic, like
    pushes and pulls. The idea is that the system administrator sets
    up a `gitadmin' system user, and configures the `authorized_keys'
    file which is maintained by gitadmin as the SshAuthorizedKeysFile
    for that system user.
"""

shell_intro = "Welcome to gitadmin. Type 'info' for a list of available commands"

shell_prompt = "gitadmin> "

commands_listing = r"""
 Root admin commands:

   su USER CMD...
   create_domain DOMAIN COMMENT
   delete_domain DOMAIN
   create_user USER COMMENT
   delete_user USER
                                              User commands:
 Domain admin commands:
                                                info
   admins DOMAIN                                whoami
   repos DOMAIN                                 users
   repo_perms DOMAIN REPO                       domains
   set_domain_admin DOMAIN USER                 perms
   unset_domain_admin DOMAIN USER               sshkeys
   create_repo DOMAIN REPO COMMENT              add_sshkey
   delete_repo DOMAIN REPO                      remove_sshkey
   set_repo_desc DOMAIN REPO COMMENT         guests
   set_perm DOMAIN REPO USER <none|R|RW>        create_guest USER COMMENT
   set_public DOMAIN REPO <true|false>          delete_guest USER

"""

sql_schema_version = "0.1"
sql_schema = r"""
CREATE TABLE gitadmin_metadata
( schema_version VARCHAR NOT NULL
);

CREATE TABLE user
( user VARCHAR NOT NULL
, desc VARCHAR NOT NULL
--
, PRIMARY KEY (user)
);

CREATE TABLE domain
( domain VARCHAR NOT NULL
, desc   VARCHAR NOT NULL
--
, PRIMARY KEY (domain)
);

CREATE TABLE repo
( domain VARCHAR NOT NULL
, repo   VARCHAR NOT NULL
, desc   VARCHAR NOT NULL
--
, PRIMARY KEY (domain, repo)
, FOREIGN KEY (domain) REFERENCES domain (domain)
);

CREATE TABLE sshkey
( user VARCHAR NOT NULL
, algo VARCHAR NOT NULL
, key  VARCHAR NOT NULL
, desc VARCHAR NOT NULL
--
, PRIMARY KEY (user, key)
, FOREIGN KEY (user) REFERENCES user (user)
);

CREATE TABLE admin
( domain VARCHAR NOT NULL
, user   VARCHAR NOT NULL
--
, PRIMARY KEY (domain, user)
, FOREIGN KEY (domain) REFERENCES domain (domain)
, FOREIGN KEY (user)   REFERENCES user   (user)
);

CREATE TABLE perm
( domain VARCHAR NOT NULL
, repo   VARCHAR NOT NULL
, user   VARCHAR NOT NULL
, perm   VARCHAR NOT NULL
--
, PRIMARY KEY (domain, repo, user)
, FOREIGN KEY (domain, repo) REFERENCES repo (domain, repo)
, FOREIGN KEY (user)         REFERENCES user (user)
, CHECK (perm == "R" OR perm == "RW")
);

CREATE TABLE publicro
( domain VARCHAR NOT NULL
, repo   VARCHAR NOT NULL
--
, PRIMARY KEY (domain, repo)
, FOREIGN KEY (domain) REFERENCES domain (domain)
, FOREIGN KEY (repo)   REFERENCES repo   (repo)
);

CREATE TABLE guest
( guest  VARCHAR NOT NULL
, host   VARCHAR NOT NULL
--
, PRIMARY KEY (guest, host)
, FOREIGN KEY (guest) REFERENCES user (user)
, FOREIGN KEY (host)  REFERENCES user (user)
);
"""


# *****************************************************************************
# Exceptions
# *****************************************************************************

#
# Custom exceptions modeling gitadmin semantics. All runtime exceptions that
# the author thought of and cared about are immediately converted to one of
# these custom exceptions.
#
# All other exceptions are bugs.
#

class GA_FSError(Exception):
    """A kind-of unexpected error from the filesystem or the OS during a
       gitadmin operation"""
    msg = "FS-ERROR"

class GA_DBError(Exception):
    """A kind-of unexpected error from the database or the OS during a gitadmin
       operation"""
    msg = "DB-ERROR"

class GA_CLIError(Exception):
    """Wrong command-line invocation"""
    msg = "COMMANDLINE-ERROR"

class GA_Invalid(Exception):
    """gitadmin command could not be parsed, or wrong number of arguments, or
       one or more arguments did not match the according regular expression"""
    msg = "INVALID-COMMAND"

class GA_Unauthorized(Exception):
    """A parsed command could not be processed due to insufficient
       authorization"""
    msg = "UNAUTHORIZED"

class GA_NotFound(Exception):
    """An object reference could not be resolved"""
    msg = "NOT-FOUND"

class GA_Exists(Exception):
    """An attempt was made to create an object which already exists"""
    msg = "EXISTS"

class GA_FailedDependencies(Exception):
    """An operation could not be performed because some other operation needs
       to be performed first (like deleting all repos from a domain before the
       domain can be deleted)"""
    msg = "FAILED-DEPENDENCIES"


# **********************************************************************
# VARIOUS HELPER FUNCTIONS
# **********************************************************************

# regex matching wrapper

def exact_match(regex, value):
    return re.match(r'^' + regex + r'$', value) is not None

# File system wrapper
# 
# Collapse all error conditions into GA_FSError. Semantics are that simple:
# When an FS operation is not successful, that's unexpected. We are in a bad
# state and bail out.

def mkdir(dirpath):
    try:
        os.mkdir(dirpath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to create directory: {}".format(e))

def rmdir(dirpath):
    try:
        os.rmdir(dirpath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to remove directory: {}".format(e))

def symlink(filepath, linkpath):
    try:
        os.symlink(filepath, linkpath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to create symlink: {}".format(e))

def unlink(filepath):
    try:
        os.unlink(filepath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to unlink: {}".format(e))

def write_file(filepath, rawbytes):
    try:
        with open(filepath, 'wb') as f:
            f.write(rawbytes)
    except (OSError, IOError) as e:
        raise GA_FSError("Failed to write file: {}".format(e))

# Database wrapper
#
# Similarly to FS, any DB errors (like I/O errors, messed up database, or
# integrity errors resulting from program logic bugs) are unexpected. When one
# occurrs, raise GA_DBError. The other parts of the program won't try to handle
# this condition.

def create_db():
    if os.path.exists(path_database()):
        raise GA_DBError("Database exists. Refusing to create")
    try:
        conn = sqlite3.connect(path_database(), isolation_level=None)
        conn.execute("PRAGMA FOREIGN_KEYS = ON")
        conn.executescript(sql_schema)
        conn.execute("INSERT INTO gitadmin_metadata (schema_version) VALUES (?)", (sql_schema_version,))
        conn.close()
    except sqlite3.Error as e:
        raise GA_DBError("Error creating Database: {}".format(e))

def connect_db():
    global conn
    if not os.path.exists(path_database()):
        raise GA_DBError("Database doesn't exist. Call 'gitadmin --init'")
    try:
        conn = sqlite3.connect(path_database(), isolation_level=None)
        conn.execute("PRAGMA FOREIGN_KEYS = ON")
        rows = conn.execute("SELECT schema_version FROM gitadmin_metadata")
        if tuple(rows) != ((sql_schema_version,),):
            raise GA_DBError("Error opening Database: Wrong Database schema version. Probably gitadmin was upgraded and the DB needs migration")
    except sqlite3.Error as e:
        raise GA_DBError("Error opening Database: {}".format(e))

def disconnect_db():
    global conn
    try:
        conn.close()
    except sqlite3.Error as e:
        raise GA_DBError("Error closing Database: {}".format(e))
    conn = None

def begin_db_transaction():
    global conn
    try:
        conn.execute("BEGIN TRANSACTION")
    except sqlite3.Error as e:
        raise GA_DBError("Error starting DB transaction: {}".format(e))

def end_db_transaction():
    global conn
    try:
        conn.execute("END TRANSACTION")
    except sqlite3.Error as e:
        raise GA_DBError("Error committing DB transaction: {}".format(e))

def abort_db_transaction():
    global conn
    try:
        conn.execute("ROLLBACK")
    except sqlite3.Error as e:
        raise GA_DBError("Error while aborting DB transaction: {}".format(e))

def select(sql, args=()):
    global conn
    try:
        rs = conn.execute(sql, args)
        return list(rs)
    except sqlite3.Error as e:
        raise GA_DBError("Error while executing DB command: {}".format(e))

def exists(sql, args=()):
    global conn
    try:
        rs = conn.execute(sql, args)
        return bool(list(rs))
    except sqlite3.Error as e:
        raise GA_DBError("Error while executing DB command: {}".format(e))

def delete(sql, args=()):
    global conn
    try:
        conn.execute(sql, args)
        rs = conn.execute("SELECT CHANGES()")
        return list(rs)[0][0]
    except sqlite3.Error as e:
        raise GA_DBError("Error while executing DB command: {}".format(e))

def insert(sql, args=()):
    global conn
    try:
        conn.execute(sql, args)
    except sqlite3.Error as e:
        raise GA_DBError("Error while executing DB command: {}".format(e))

def with_db(fun, *args):
    connect_db()
    try:
        return fun(*args)
    finally:
        disconnect_db()

def run_transaction(fun, *args):
    begin_db_transaction()
    try:
        r = fun(*args)
    except:
        abort_db_transaction()
        raise
    else:
        end_db_transaction()
        return r


# *****************************************************************************
# USER INPUT VALIDATION PRIMITIVES
# *****************************************************************************

def is_single_line(x):
    """helper for need_* functions"""
    return '\n' not in x and '\r' not in x

def is_word(x):
    """helper for need_* functions"""
    return x.isidentifier()  # hope this will do

def is_fs_component(x):
    """helper for need_* functions."""
    return x.isidentifier() and x not in ['.','..'] and '/' not in x and '\\' not in x

#

def need_valid_username(user):
    if not is_word(user) or not exact_match(username_regex, user):
        raise GA_Invalid("'{}' is not a valid user name".format(user))

def need_valid_guestname(user):
    if not user.startswith('guest-'):
        raise GA_Invalid("'{}' is not a valid guest user name (must start with guest-)".format(user))
    if not exact_match(r'guest-' + username_regex, user):
        raise GA_Invalid("'{}' is not a valid guest user name".format(user))

def need_valid_domainname(domain):
    if not is_fs_component(domain) or not exact_match(domainname_regex, domain):
        raise GA_Invalid("'{}' is not a valid domain name".format(domain))

def need_valid_reponame(repo):
    if not is_fs_component(repo) or not exact_match(reponame_regex, repo):
        raise GA_Invalid("'{}' is not a valid repo name".format(repo))

def need_valid_userdesc(desc):
    if not is_single_line or not exact_match(userdesc_regex, desc):
        raise GA_Invalid("'{}' is not a valid user desc".format(desc))

def need_valid_domaindesc(desc):
    if not is_single_line or not exact_match(domaindesc_regex, desc):
        raise GA_Invalid("'{}' is not a valid domain desc".format(desc))

def need_valid_repodesc(desc):
    if not is_single_line or not exact_match(repodesc_regex, desc):
        raise GA_Invalid("'{}' is not a valid repo desc".format(desc))

def need_valid_boolean(boolean):
    if boolean not in ['true', 'false']:
        raise GA_Invalid("'{}' is not a valid boolean. Need 'true' or 'false'".format(boolean))

def need_valid_repospec(path):
    # Try to parse the git repo path the way a normal POSIX sh would parse it.
    # For example, when you say:
    #
    # $ git clone git@foo.com/joe/project
    #
    # git does something like:
    #
    # $ ssh git@foo.com "git-upload-pack 'joe/project'"
    #
    # This function gets the last part as a python string: "'joe/project'"
    # It must return a python tuple: ('joe', 'project')
    ws = shlex.split(path)
    if len(ws) == 1:
        xs = ws[0].split('/')
        if len(xs) == 2:
            d, r = xs
            need_valid_domainname(d)
            need_valid_reponame(r)
            return d, r
    raise GA_Invalid("Could not parse {} as a valid repospec (something like 'joe/project')".format(path))

def need_cmd_array(cmd_string):
    #
    # Should shell-style splitting really be reimplemented?
    #
    # Maybe we could get along with just whitespace splitting (comments as the
    # only thing where whitespace is allowed are always in the last column)
    #
    # The shlex module could be used as well. But shlex's supported syntax is
    # even more complicated than the one implemented below.
    #
    cmd = ()
    word = ""
    started = False
    quoted = False
    escaped = False
    for char in cmd_string:
        if escaped:
            word += char
            escaped = False
        elif char == '\\':
            escaped = True
            started = True
        elif char == '"':
            quoted = not quoted
            started = True
        elif quoted or char not in ' \t\n\r':
            word += char
            started = True
        elif started:
            cmd = cmd + (word,)
            word = ''
            started = False
    if quoted:
        raise GA_Invalid("Unterminated quote: {}".format(cmd_string))
    if escaped:
        raise GA_Invalid("Trailing escape character: {}".format(cmd_string))
    if started:
        cmd = cmd + (word,)
    return cmd


# **********************************************************************
# AUTHORIZATION PRIMITIVES
# **********************************************************************

def require_root_admin():
    if loguser is not None:
        raise GA_Unauthorized("root admin privileges needed")

def require_domain_admin(domain):
    adm = db_list_domain_admins(domain)
    if loguser not in map(lambda r: r[1], adm):
        raise GA_Unauthorized("domain admin privileges needed")

def require_regular_user():
    if loguser is None:
        # XXX: weird to forbid root something and other users not
        raise GA_Unauthorized("root user can't create guests")
    guests = db_list_guests()
    if loguser in guests:
        raise GA_Unauthorized("guests are not allowed to create other guests")

def require_host_of_guest(guest):
    if loguser is not None:
        # XXX: weird to forbid root something and other users not
        raise GA_Unauthorized("root user can't delete guests")
    guests = db_list_user_guests(loguser)
    if guest not in guests:
        raise GA_Unauthorized("not one of your guests")


# **********************************************************************
# FORMATTING
# **********************************************************************

def format_authorized_keys(rs):
    return ''.join('command="gitadmin -u {}" {} {} {}\n'.format(user, algo, key, desc) for user, algo, key, desc in rs)

def format_table(rs):
    # TODO: Not here
    if not is_stdout_tty:
        return ''.join('\t'.join(c for c in r) + '\n' for r in rs)

    lss = zip(*[[len(c) for c in r] for r in rs])
    ls = [max(ls) for ls in lss]
    xs = [[str(c).ljust(l) for c, l in list(zip(r, ls))[:-1]] + [r[-1]] for r in rs]
    return ''.join('\t'.join(r) + '\n' for r in rs)


# **********************************************************************
# FILE PATHS
# **********************************************************************

def path_base_dir():
    return os.path.join(config_basedir)

def path_repos_dir():
    return os.path.join(config_basedir, 'repos')

def path_authorized_keys():
    return os.path.join(config_basedir, 'authorized_keys')

def path_database():
    return os.path.join(config_basedir, 'gitadmin.sqlite3')

def path_domain_dir(domain):
    return os.path.join(config_basedir, 'repos', domain)

def path_repo_dir(domain, repo):
    return os.path.join(config_basedir, 'repos', domain, repo)

def path_repodesc(domain, repo):
    return os.path.join(config_basedir, 'repos', domain, repo, 'description')

def path_publicro_dir():
    return os.path.join(config_basedir, 'publicro')

def path_publicro_domain_dir(domain):
    return os.path.join(config_basedir, 'publicro', domain)

def path_publicro_repo_symlink(domain, repo):
    return os.path.join(config_basedir, 'publicro', domain, repo)


# **********************************************************************
# FS LOGIC
# **********************************************************************

def fs_initialize():
    mkdir(path_base_dir())
    mkdir(path_repos_dir())
    mkdir(path_publicro_dir())
    write_file(path_authorized_keys(), bytes('', 'UTF-8'))
    # create db at the end. This way an incompletely
    # initialized basedir will be easily detected
    create_db()

def fs_make_domain_dir(domain):
    mkdir(path_domain_dir(domain))

def fs_remove_domain_dir(domain):
    rmdir(path_domain_dir(domain))

def fs_create_repo(domain, repo):
    # output from git binary is leaked to the user
    checked_call("git", "init", "--bare", repo_dirpath(domain, repo))

def fs_delete_repo(domain, repo):
    # output from git binary is leaked to the user
    checked_call("rm", "-r", repo_dirpath(domain, repo))

def fs_set_repodesc(domain, repo, desc):
    write_file(path_repodesc(domain, repo), bytes(desc, 'UTF-8'))

def fs_set_publicro_symlink(domain, repo):
    symlink(path_publicro_repo_symlink(domain, repo))

def fs_clear_publicro_symlink(domain, repo):
    unlink(path_publicro_repo_symlink(domain, repo))


# **********************************************************************
# DB LOGIC
# **********************************************************************

#
# These functions translate between the relational view of the database and the
# more object-oriented gitadmin view.
#
# Although this section might seem isomorphic to the available gitadmin tasks,
# the idea is that here we put DB *primitives* (transitions between valid
# gitadmin DB states), and generally gitadmin tasks compound them.
#
# Also we want to put here all the SQL, and nothing else, for readability.
#
# Instead of using a complicated ORM mapper, we write some ad-hoc code.
#
# Note: I found ORM to be straightforward (in this narrow-scoped program).
# I mostly went Relations -> Entity-Relatinship -> Objects:
#
# 0. Create the DB schema first. OO is broken. If you can't make a DB schema,
#    you don't know what model you want logically (or you want too much).
#
# 1. Work out what relations easily map to (the top-level) of objects from the
#    OO world. Here we have user, domain and possibly repo and possibly sshkey.
#
# 2. Provide Constructors (db_insert_*), Destructors (db_delete_*), Getters and
#    Setters for these. (The last two are currently missing here)
#
# 3. Look at the remaining relations as the beautiful simple data (often
#    vectors) which in OOP you would store with objects where they clearly
#    don't belong (because they could be stored with other objects just as
#    well).  Think what methods you would install on the objects in OOP for
#    massaging this data, and provide corresponding DB functions.
#
# What's there below:
#
# - All functions assert that the references given as function arguments exist
#   (except where they are meant to be "created")
#
# - db_list_* are read-only. They return tuples of flat tuples (i.e, relations)
#
# - db_insert_* raise GA_Exists if the "object" to be inserted already exists.
#
# - db_delete_* raise GA_NotFound if the "object" to be deleted doesn't exist,
#   or GA_FailedDependencies if a precondition for deletion isn't fulfilled.
#
# - db_set_* and db_clear_* return None. They are idempotent. GA_NotFound is
#   raised when a referenced object doesn't exist.
#

def db_list_users():
    rows = select("SELECT user, desc FROM user")
    return format_table(rows)

def db_list_guests():
    return select("SELECT user, desc FROM user, guest WHERE user = guest")

def db_list_sshkeys():
    return select("SELECT user, algo, key, desc FROM sshkey")

def db_list_domains():
    return select("SELECT domain, desc FROM domain")

def db_list_repos():
    return select("SELECT domain, repo, desc FROM repo")

def db_list_admins():
    return select("SELECT domain, user FROM admin")

def db_list_user_perms(user):
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    return select("SELECT domain, repo, user, perm FROM perm WHERE user = ?", (user,))

def db_list_user_guests(user):
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    return select("SELECT user, desc FROM user, guest WHERE user = guest AND host = ?", (user,))

def db_list_user_sshkeys(user):
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    return select("SELECT user, algo, key, desc FROM sshkey WHERE user = ?", (user,))

def db_list_domain_admins(domain):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    return select("SELECT domain, user FROM admin WHERE domain = ?", (domain,))

def db_list_domain_repos(domain):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    return select("SELECT domain, repo, desc FROM repo WHERE domain = ?", (domain,))

def db_list_user_domains(user):
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    return select("SELECT domain, user FROM admin WHERE user = ?", (user,))

def db_list_repo_perms(domain, repo):
    assert exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo))
    return select("SELECT domain, repo, user, perm FROM perm WHERE domain = ? AND repo = ?", (user,))

def db_insert_user(user, desc):
    if exists("SELECT 1 FROM user WHERE user = ?", (user,)):
        raise GA_Exists("User already exists")
    insert("INSERT INTO user (user, desc) VALUES (?, ?)", (user, desc))

def db_insert_domain(domain, desc):
    if exists("SELECT 1 FROM domain WHERE domain = ?", (domain,)):
        raise GA_Exists("Domain already exists")
    insert("INSERT INTO domain (domain, desc) VALUES (?, ?)", (domain, desc))

def db_insert_repo(domain, repo, desc):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    if exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_Exists("Repo already exists")
    insert("INSERT INTO repo (domain, repo, desc) VALUES (?, ?, ?)", (domain, repo, desc))

def db_insert_sshkey(user, algo, key, desc):
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    if exists("SELECT 1 FROM sshkey WHERE key = ?", (key,)):
        raise GA_Exists("SSH key already registered")
    insert("INSERT INTO sshkey (user, algo, key, desc) VALUES (user, algo, key, desc)", (user, algo, key, desc))

def db_delete_user(user):
    # also works for deletion of guests
    if not exists("SELECT 1 FROM user WHERE user = ?", (user,)):
        raise GA_NotFound("User not found")
    delete("DELETE FROM guest WHERE host = ?", (user,))
    delete("DELETE FROM guest WHERE guest = ?", (user,))
    delete("DELETE FROM sshkey WHERE user = ?", (user,))
    delete("DELETE FROM admin WHERE user = ?", (user,))
    delete("DELETE FROM perm WHERE user = ?", (user,))
    delete("DELETE FROM user WHERE user = ?", (user,))

def db_delete_domain(domain):
    if not exists("SELECT 1 FROM domain WHERE domain = ?", (domain,)):
        raise GA_NotFound("Domain not found")
    if exists("SELECT 1 FROM repo WHERE domain = ?", (domain,)):
        raise GA_FailedDependencies("Domain not empty")
    delete("DELETE FROM admin WHERE domain = ?", (domain,))
    delete("DELETE FROM domain WHERE domain = ?", (domain,))

def db_delete_repo(domain, repo):
    if not exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("Repo not found")
    delete("DELETE FROM publicro WHERE domain = ? AND repo = ?", (domain, repo))
    delete("DELETE FROM perm WHERE domain = ? AND repo = ?", (domain, repo))
    delete("DELETE FROM repo WHERE domain = ? AND repo = ?", (domain, repo))

def db_delete_sshkey(user, algo, key):
    # ignoring algo completely. Good idea?
    if not exists("SELECT 1 FROM sshkey WHERE user = ? AND key = ?", (user, key)):
        raise GA_NotFound("SSH key not found or not your key")
    delete("DELETE FROM sshkey WHERE user = ? AND key = ?", (user, key))

def db_set_admin(domain, user):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    insert("INSERT OR IGNORE INTO admin (domain, user) VALUES (?, ?)", (domain, user))

def db_clear_admin(domain, user):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    delete("DELETE FROM admin WHERE domain = ? AND user = ?", (domain, user))

def db_set_perm(domain, repo, user, perm):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    assert exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo))
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    assert perm == "R" or perm == "RW"
    insert("INSERT OR UPDATE INTO perm (domain, repo, user, perm) VALUES (?, ?, ?, ?)", (domain, repo, user, perm))

def db_clear_perm(domain, repo, user):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    assert exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo))
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    delete("DELETE FROM perm WHERE domain = ? AND repo = ? AND user = ?", (domain, repo, user))

def db_set_publicro(domain, repo):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    assert exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo))
    insert("INSERT OR IGNORE INTO publicro (domain, repo) VALUES (?, ?)", (domain, repo))

def db_clear_publicro(domain, repo):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    assert exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo))
    delete("DELETE FROM publicro (domain, repo) WHERE domain = ? AND repo = ?", (domain, repo))

def db_set_host(guest, host):
    assert exists("SELECT 1 FROM user WHERE user = ?", (guest,))
    assert exists("SELECT 1 FROM user WHERE user = ?", (host,))
    # there's no corresponding clear routine.
    insert("INSERT OR IGNORE INTO guest (guest, host) VALUES (?, ?)", (guest, host))


# **********************************************************************
# GIT CALLS
# **********************************************************************

def git_upload_pack(domain, repo):
    checked_call("git-upload-pack", "{}/{}".format(domain, repo))

def git_receive_pack(domain, repo):
    checked_call("git-receive-pack", "{}/{}".format(domain, repo))


# **********************************************************************
# GITADMIN TASKS
# **********************************************************************

# Here we implement the user-facing commands.
#
# The implementation for each command CMD is split into these parts:
#
# valid_CMD(): arguments to CMD are check for syntactical (regex) validity.
# ask_CMD():   any missing required arguments are obtained interactively.
# auth_CMD():  arguments are check for authorization (first DB read access)
# task_CMD():  DB + FS transaction
#              DB always comes first because we can't revert FS operation
#              State will be left inconsistent when FS fails.
#

def valid_info():
    return

def valid_whoami():
    return

def valid_users():
    return

def valid_domains():
    return

def valid_perms():
    return

def valid_sshkeys():
    return

def valid_guests():
    return

def valid_add_sshkey():
    return

def valid_remove_sshkey():
    return

def valid_create_user(user, desc):
    need_valid_username(user)
    need_valid_userdesc(desc)

def valid_delete_user(user):
    need_valid_username(user)

def valid_create_guest(guest, desc):
    need_valid_guestname(guest)
    need_valid_userdesc(desc)

def valid_delete_guest(guest):
    need_valid_guestname(guest)

def valid_create_domain(domain, desc):
    need_valid_domainname(domain)
    need_valid_domaindesc(desc)

def valid_delete_domain(domain):
    need_valid_domainname(domain)

def valid_create_repo(domain, repo, desc):
    need_valid_domainname(domain)
    need_valid_reponame(repo)
    need_valid_repodesc(desc)

def valid_delete_repo(domain, repo):
    need_valid_domainname(domain)
    need_valid_reponame(repo)

def valid_set_public(domain, repo, public):
    need_valid_domainname(domain)
    need_valid_reponame(repo)
    need_valid_boolean(public)

#

def auth_info():
    return

def auth_whoami():
    return

def auth_users():
    return

def auth_domains():
    return

def auth_perms():
    return

def auth_sshkeys():
    return

def auth_guests():
    return

def auth_add_sshkey():
    return

def auth_remove_sshkey():
    return

def auth_create_user(user, desc):
    require_root_admin()

def auth_delete_user(user):
    require_root_admin()

def auth_create_guest(guest, desc):
    require_regular_user()

def auth_delete_guest(guest):
    require_host_of_guest(guest)

def auth_create_domain(domain, desc):
    require_root_admin()

def auth_delete_domain(domain):
    require_root_admin()

def auth_create_repo(domain, repo, desc):
    require_domain_admin(domain)

def auth_delete_repo(domain, repo):
    require_domain_admin(domain)

def auth_set_perm(domain, repo, user, perm):
    require_domain_admin(domain)

def auth_set_public(domain, repo, public):
    require_domain_admin(domain)

#

def task_info():
    return [commands_listing]

def task_whoami():
    return [(loguser or '(root)') + '\n']

def task_users():
    return db_list_users()

def task_domains():
    return db_list_user_domains(loguser)

def task_repos(domain):
    return db_list_domain_repos(domain)

def task_admins(domain):
    return db_list_domain_admins(domain)

def task_perms():
    return db_list_user_perms(loguser)

def task_repo_perms(domain, repo):
    return db_list_repo_perms(domain, repo)

def task_sshkeys():
    return db_list_user_sshkeys(loguser)

def task_guests():
    return db_list_user_guests(loguser)

def task_add_sshkey(algo, key, desc):
    db_insert_sshkey(loguser, algo, key, desc)

def task_remove_sshkey(algo, key, desc):
    db_delete_sshkey(algo, key)

def task_create_user(user, desc):
    db_insert_user(user, desc)

def task_delete_user(user):
    db_delete_user(user)

def task_create_guest(guest, desc):
    db_insert_user(guest, desc)
    db_set_host(guest, loguser)

def task_delete_guest(guest):
    db_delete_user(guest)

def task_create_domain(domain, desc):
    db_insert_domain(domain, desc)
    fs_make_domain_dir(domain)

def task_delete_domain(domain):
    db_delete_domain(domain)
    fs_remove_domain_dir(domain)

def task_create_repo(domain, repo, desc):
    db_insert_repo(domain, repo, desc)
    fs_create_repo(domain, repo)

def task_delete_repo(domain, repo):
    db_delete_repo(domain, repo, desc)
    fs_delete_repo(domain, repo)

def task_set_admin(domain, user, admin):
    if admin:
        db_set_admin(domain, user)
    else:
        db_clear_admin(domain, user)

def task_set_public(domain, repo, public):
    if public:
        fs_set_publicro_symlink(domain, repo)
    else:
        fs_clear_publicro_symlink(domain, repo)


# **********************************************************************
# COMMAND EXECUTION
# **********************************************************************

def exec_git_upload_pack(rest):
    domain, repo = need_repospec_from_git_repo_path(rest)

    require_read_perm(domain, repo)

    git_upload_pack(domain, repo)

def exec_git_receive_pack(rest):
    domain, repo = need_repospec_from_git_repo_path(rest)

    require_write_perm(domain, repo)

    git_receive_pack(domain, repo)

def exec_cmd_array(user, args):
    global loguser

    if not args:
        return

    if user is None and len(args) >= 2 and args[0] == 'su':
        user = args[1]
        args = args[2:]

    auth  = globals().get('auth_'  + args[0])
    valid = globals().get('valid_' + args[0])
    task  = globals().get('task_'  + args[0])

    if auth is None or valid is None or task is None:
        raise GA_Invalid("No such command: " + args[0])

    auth_spec  = inspect.getargspec(auth)
    valid_spec = inspect.getargspec(valid)
    task_spec  = inspect.getargspec(task)

    assert auth_spec == valid_spec == task_spec

    if ((task_spec[1] is None and len(args) - 1 != len(task_spec[0])) or
        (task_spec[1] is not None and len(args) - 1 < len(task_spec[0]))):
        raise GA_Invalid("too few or too many arguments. Usage: {} {}".format(args[0], ' '.join(x.upper() for x in task_spec[0])))

    loguser = user

    try:
        valid(*args[1:])

        def execute():
            auth(*args[1:])
            return task(*args[1:])

        r = run_transaction(execute)

        for x in list(r or []):
            sys.stdout.write(x)

    finally:
        loguser = None


# **********************************************************************
# INTERACTIVE SHELL
# **********************************************************************

class GitAdminShell(cmd.Cmd):
    # Sorry to say it, but cmd.Cmd is not a good API

    intro = shell_intro
    prompt = shell_prompt

    def __init__(self, user):
        # Override the bad default to output prompts to sys.stdout.
        # The docs don't hint that the completekey default argument of 'Tab' is
        # really a string (!). Giving None instead doesn't restore the default
        # behaviour but instead disables completion -- but hey, that saved one
        # configuration option.
        super().__init__('Tab', sys.stdin, sys.stderr)

        self.user = user
        if user is None:
            print("Starting root admin shell...", file=sys.stderr)
        else:
            print("Logged in as {}".format(user), file=sys.stderr)

    # We need to override this method because the default is to repeat
    # the last command.
    def emptyline(self):
        pass

    # 'EOF' (a string) is used to indicate that the stdin stream has ended. Not
    # making this up. And why do we need to handle this at all by default?
    def default(self, line):
        if line in ['EOF', 'exit', 'quit']:
            # On EOF, before exiting, end the line which the prompt started.
            if line == 'EOF':
                print('', file=sys.stderr)
            # indicate that the interpreter should be ended
            return True
        else:
            exec_cmd_array(self.user, need_cmd_array(line))

    # We must override this method to be able to handle exceptions from
    # executed commands
    def onecmd(self, line):
        try:
            # All commands should return None, except default() above where we
            # return True for EOF, exit, or quit
            return super().onecmd(line)
        except (GA_CLIError,
                GA_Unauthorized,
                GA_NotFound,
                GA_Exists,
                GA_FailedDependencies) as e:
            print("ERROR ({}): {}".format(e.msg, e, file=sys.stderr))
            return False

    # We must override this method because keyboard interrupts at the prompt
    # can't be handled in onecmd(). This will cost some stack space, but who
    # cares.
    def cmdloop(self):
        try:
            return super().cmdloop()
        except KeyboardInterrupt as e:
            # start a new line
            print(file=sys.stderr)
            # before looping again, make sure intro won't be displayed again.
            self.intro = None
            return self.cmdloop()

# By default, the built-in do_help command prints a barely useful compilation of
# registered do_* commands. Also, "help" is autocompleted. Don't tell anyone
# what we're doing here!
delattr(cmd.Cmd, 'do_help')


# **********************************************************************
# MAIN
# **********************************************************************

def wrong_usage():
    print(help_short, file=sys.stderr)
    sys.exit(1)

def invoke_help():
    print(long_usage)

def invoke_init():
    fs_initialize()

def invoke_with_cmdarray(user, cmd_array):
    with_db(exec_cmd_array, user, cmd_array)

def invoke_with_cmdstring(user, cmd_string):
    with_db(exec_cmd_array, user, need_cmd_array(cmd_string))

def invoke_with_sshoriginalcommand(user, ssh_original_command):
    ws = ssh_original_command.split(None, 1)
    if len(ws) == 2 and ws[0] == 'git-upload-pack':
        with_db(exec_git_upload_pack, ws[1])
    elif len(ws) == 2 and ws[0] == 'git-receive-pack':
        with_db(exec_git_receive_pack, ws[1])
    elif len(ws) == 2 and ws[0] == 'gitadmin':
        with_db(exec_cmd_array, need_cmd_array(ws[1]))
    else:
        raise GA_Invalid("Invalid invocation (SSH_ORIGINAL_COMMAND): need \"git-(upload|receive)-pack 'DOMAIN/REPO'\" or \"gitadmin <GITADMIN-CMD>\"", file=sys.stderr)

def invoke_shell(user):
    if is_stdin_tty and is_stderr_tty:
        shell = GitAdminShell(user)
        with_db(shell.cmdloop)
    else:
        for line in sys.stdin:
            with_db(exec_cmd_array, user, need_cmd_array(line))

def gitadmin(argv, ssh_original_command=None):
    argv = tuple(argv[1:])

    wantinit = None
    wanthelp = None
    req_user = None
    cmd_string = None
    cmd_array = None

    if len(argv) >= 1 and argv[0] == '--init':
        wantinit = ()
        argv = argv[1:]
    if len(argv) >= 1 and argv[0] == '--help':
        wanthelp = ()
        argv = argv[1:]
    if len(argv) >= 2 and argv[0] == '-u':
        req_user = argv[1]
        argv = argv[2:]
    if len(argv) >= 2 and argv[0] == '-c':
        cmd_string = argv[1]
        argv = argv[2:]
    if len(argv) and not argv[0].startswith('-'):
        cmd_array = tuple(argv)
        argv = ()

    if len(argv):
        wrong_usage()

    def exclusive(*opts):
        notnone = [o for o in opts if o is not None]
        if len(notnone) > 1:
            wrong_usage()

    exclusive(wantinit, wanthelp, cmd_array, cmd_string)
    exclusive(wantinit, wanthelp, req_user)

    if wanthelp is not None:
        invoke_help()
    elif wantinit is not None:
        invoke_init()
    elif cmd_array is not None:
        invoke_with_cmdarray(req_user, cmd_array)
    elif cmd_string is not None:
        invoke_with_cmdstring(req_user, cmd_string)
    elif ssh_original_command is not None:
        invoke_with_sshoriginalcommand(req_user, ssh_original_command)
    else:
        invoke_shell(req_user)

if __name__ == '__main__':
    try:
        gitadmin(sys.argv, os.getenv('SSH_ORIGINAL_COMMAND'))
        sys.exit(0)
    except GA_CLIError as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(1)
    except GA_Invalid as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(2)
    except GA_Unauthorized as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(3)
    except GA_NotFound as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(4)
    except GA_Exists as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(5)
    except GA_FailedDependencies as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(6)
    except (GA_DBError, GA_FSError, Exception) as e:
        print("gitadmin: ERROR: Oops! {}. Please contact your system or network administrator".format(e), file=sys.stderr)
        sys.exit(13)
