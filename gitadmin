#!/usr/bin/env python3

import os
import re
import readline, cmd
import sqlite3
import subprocess
import sys

config = {
    'basedir':
        os.path.join(os.getenv('HOME'), 'basedir'),  # XXX
    'authorized_keys':
        os.path.join(os.getenv('HOME'), '.ssh/authorized_keys')  # XXX
}

# runtime state
conn = None
# state which will remain constant after this initialization
is_stdin_tty = os.isatty(sys.stdin.fileno())
is_stdout_tty = os.isatty(sys.stdout.fileno())
is_stderr_tty = os.isatty(sys.stderr.fileno())
# This will be determined when the command line is parsed.
# Its value will depend on is_std{in,out,err}_tty and the run mode.
# Once set, it remains constant
is_interactive = None
# these will be set when the database connection is made
# (that means, not for --help and --init run modes)
# They remain constant once set, except they might be temporarily swapped by
# "su"
loguser = None
loguid = None
is_root = False
stored_loguser = None
stored_loguid = None

short_usage = """\
gitadmin invocation:

    gitadmin --help
    gitadmin --init
    gitadmin ARGS...
    gitadmin [-u USER]
    gitadmin [-u USER] -c COMMAND
    SSH_ORIGINAL_CMD=GITCMD gitadmin [-u USER]
"""

long_usage = short_usage + """
In the first case, print this help message.

In the second case, initialize a new gitadmin environment. gitadmin will abort
if an existing environment is found.

In the third case, the argument list is interpreted as a single gitadmin
command. The arguments must form a pre-split valid gitadmin command. For
example, a valid gitadmin invocation from sh would be

    $ gitadmin create_user john "John Doe"

In the fourth case, run the gitadmin shell interpreter using
stdin/stdout/stderr.  The shell is run in interactive mode if all standard
streams are connected to a tty, and otherwise in noninteractive mode. if USER is
given, run the shell as this gitadmin user. Commands are read from stdin line by
line, and split into words using a very simple algorithm: Splitting occurs at
whitespace, but it is possible to prevent splitting by enclosing parts with
double quotes. Inside double quotes, the special sequences \\ and \" are
interpreted to mean the characters \ and " respectively, but otherwise the
string is taken literally.  Example gitadmin shellscript line:

create_user john "John \"yo mama's fat\" Doe"

In the fifth case, run the gitadmin shell in noninteractive mode over COMMAND
which must be a single argument. Example gitadmin invocation from sh:

    $ gitadmin -u john -c 'set_perm johnsdomain johnsrepo jane RW'

In the sixth case, validate the environment variable SSH_ORIGINAL_CMD as a valid
git request (git-receive-pack 'DOMAIN/REPO' or git-uploadpack 'DOMAIN/REPO')
"""

shell_intro = """
Welcome to gitadmin.

Type 'info' for a list of available commands
"""

shell_prompt = 'gitadmin> '

shell_usage = """
Root admin commands:

   users
   su USER CMD...
   create_domain DOMAIN FULLNAME
   delete_domain DOMAIN
   create_user USER FULLNAME
   delete_user USER

Domain admin commands:
                                            User commands:
  admins DOMAIN
  repos DOMAIN                                info
  repo_perms DOMAIN REPO                      whoami
  set_domain_admin DOMAIN USER                domains
  unset_domain_admin DOMAIN USER              perms
  create_repo DOMAIN REPO                     sshkeys
  delete_repo DOMAIN REPO                     add_sshkey
  set_perm DOMAIN REPO USER <none|R|RW>       remove_sshkey
"""

authorized_keys_header = """\
#
# THIS FILE IS MANAGED BY GITADMIN
#
"""

sqlschema = """
CREATE TABLE domain
( id INTEGER PRIMARY KEY
, name VARCHAR NOT NULL
, fullname VARCHAR NOT NULL
--
, UNIQUE (name)
);

CREATE TABLE user
( id INTEGER PRIMARY KEY
, name VARCHAR NOT NULL
, fullname VARCHAR NOT NULL
--
, UNIQUE (name)
);

CREATE TABLE sshkey
( id INTEGER PRIMARY KEY
, userid INTEGER NOT NULL
, algo VARCHAR NOT NULL
, key VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, FOREIGN KEY (userid) REFERENCES user(id)
, UNIQUE (key)
);

CREATE TABLE repo
( id INTEGER PRIMARY KEY
, domainid INTEGER NOT NULL
, name VARCHAR NOT NULL
--
, FOREIGN KEY (domainid) REFERENCES domain(id)
, UNIQUE (domainid, name)
);

CREATE TABLE permissions
( repoid INTEGER NOT NULL
, userid INTEGER NOT NULL
, mode INTEGER NOT NULL  -- 0 or 1 (R or RW)
--
, FOREIGN KEY (repoid) REFERENCES repo(id)
, FOREIGN KEY (userid) REFERENCES user(id)
, UNIQUE (repoid, userid)
);

CREATE TABLE admin
( domainid INTEGER NOT NULL
, userid INTEGER NOT NULL
--
, FOREIGN KEY (domainid) REFERENCES domain(id)
, FOREIGN KEY (userid) REFERENCES user(id)
, UNIQUE (domainid, userid)
);

INSERT INTO user (id, name, fullname) VALUES (0, "root", "");

"""

domainname_regex = r'[abcdefghijklmnopqrstuvwxyz]{2,16}'
username_regex   = r'[abcdefghijklmnopqrstuvwxyz]{2,16}'
reponame_regex   = r'[abcdefghijklmnopqrstuvwxyz0123456789-]{2,16}'
algo_regex       = (r'(?:ssh-ed25519|ssh-rsa|ssh-dss|ecdsa-sha2-nistp256'
                    r'|ecdsa-sha2-nistp384|ecdsa-sha2-nistp521)')
key_regex        = (r'[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
                    r'0123456789\+/]{32,4096}={0,2}')  # 32 and 4096 are guesses
comment_regex    = (r'[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
                    r'0123456789\+/@-]{0,64}')

dfl_cmds = {}
user_cmds = {}
domain_cmds = {}
root_cmds = {}

class GAError(Exception):
    """Expected conditions in gitadmin"""
    pass

class InvalidArgument(GAError):
    def __str__(self):
        return 'Invalid Argument: {}'.format(*self.args)

class Unauthorized(GAError):
    def __str__(self):
        return 'Permission denied: {}'.format(*self.args)

class GitAdminShell(cmd.Cmd):
    def __init__(self, intro='', prompt=''):
        super().__init__()

    intro = shell_intro
    prompt = shell_prompt

    def emptyline(self):
        pass

    def default(self, line):
        if line == 'EOF':
            print()
            sys.exit(0)
        else:
            raise InvalidArgument("Couldn't parse command")

    def onecmd(self, line):
        try:
            super().onecmd(line)
        except GAError as e:
            print("ERROR:", e, file=sys.stderr)

    def cmdloop(self):
        try:
            super().cmdloop()
        except KeyboardInterrupt as e:
            print('')
            self.intro = None  # HACK
            self.cmdloop()

def basedir_filepath():
    return config['basedir']

def authorized_keys_filepath():
    return config['authorized_keys']

def database_filepath():
    base = basedir_filepath()
    return os.path.join(base, 'gitadmin.sqlite3')

def repos_dirpath():
    base = basedir_filepath()
    return os.path.join(base, 'repos')

def domain_dirpath(domain):
    base = repos_dirpath()
    return os.path.join(base, domain)

def repo_dirpath(domain, repo):
    dirpath = domain_dirpath(domain)
    return os.path.join(dirpath, repo) + '.git'

def connect_database():
    global conn
    dbpath = database_filepath()
    if not os.path.isfile(dbpath):
        raise GAError("Database doesn't exist. Call 'gitadmin --init'")
    conn = sqlite3.connect(dbpath)
    conn.isolation_level = None
    conn.execute('PRAGMA FOREIGN_KEYS = ON')

def disconnect_database():
    global conn
    conn.close()
    conn = None

def create_database():
    dbpath = database_filepath()
    c = sqlite3.connect(dbpath)
    c.isolation_level = None
    c.execute('PRAGMA FOREIGN_KEYS = ON')
    c.executescript(sqlschema)
    c.close()

def create_authorized_keys():
    path = authorized_keys_filepath()
    f = open(path, 'w')
    f.write(authorized_keys_header)
    f.close()

def write_ssh_authorized_keys():
    rs = conn.execute("""
        SELECT U.name, S.algo, S.key, S.comment
        FROM user U JOIN sshkey S ON U.id = S.userid
    """)
    rs = list(rs)
    fpath = authorized_keys_filepath()
    tmp = fpath + '.tmp'
    with open(tmp, 'w') as f:
        f.write(authorized_keys_header)
        for r in rs:
            f.write('command="gitadmin {}" {} {} {}\n'.format(*r))
    os.rename(tmp, fpath)

def create_repos_dir():
    dirpath = repos_dirpath()
    os.mkdir(dirpath)

def create_domain_dir(domain):
    dirpath = domain_dirpath(domain)
    os.mkdir(dirpath)

def delete_domain_dir(domain):
    dirpath = domain_dirpath(domain)
    os.rmdir(dirpath)

def create_repo_git(domain, reponame):
    fpath = repo_dirpath(domain, reponame)
    subprocess.call(['git', 'init', '--bare', fpath])

def delete_repo_git(domain, reponame):
    fpath = repo_dirpath(domain, reponame)
    subprocess.call(['rm', '-rf', '--', fpath])

def exact_match(regex, x):
    return re.match(r'^' + regex + r'$', x)

def need_valid_domainname(x):
    if not exact_match(domainname_regex, x):
        raise InvalidArgument('"{}" is not a valid domain name'.format(x))

def need_valid_username(x):
    if not exact_match(username_regex, x):
        raise InvalidArgument('"{}" is not a valid user name'.format(x))

def need_valid_reponame(x):
    if not exact_match(reponame_regex, x):
        raise InvalidArgument('"{}" is not a valid repo name'.format(x))

def need_valid_algo(x):
    if not exact_match(algo_regex, x):
        raise InvalidArgument('"{}" is not a valid SSH key algo'.format(x))

def need_valid_key(x):
    if not exact_match(key_regex, x):
        raise InvalidArgument('"{}" is not a valid SSH key'.format(x))

def need_valid_comment(x):
    if not exact_match(comment_regex, x):
        raise InvalidArgument('"{}" is not a valid SSH key comment'.format(x))

def need_valid_sshkey(x):
    regex = r'({}) +({})(?: +({}))?'.format(
        algo_regex, key_regex, comment_regex
    )
    m = exact_match(regex, x)
    if m is None:
        raise InvalidArgument("Sorry, I couldn't parse the ssh key")
    x, y, z = m.groups()
    return x, y, (z or '')

def need_domain_id(domain):
    rs = conn.execute("""
        SELECT id
        FROM   domain
        WHERE  name = ?
    """, (domain,))
    rs = list(rs)
    if not rs:
        raise GAError("domain does not exist: {}".format(domain))
    return rs[0][0]

def need_user_id(user):
    rs = conn.execute("""
        SELECT id
        FROM   user
        WHERE  name = ?
    """, (user,))
    rs = list(rs)
    if not rs:
        raise GAError("user does not exist: {}".format(user))
    return rs[0][0]

def need_is_root():
    if not is_root:
        raise Unauthorized("You are not root admin")

def need_is_domain_admin(domain):
    domainid = need_domain_id(domain)
    if is_root:
        return
    rs = conn.execute("""
        SELECT 1
        FROM   admin A
        WHERE  A.domainid = ? and A.userid = ?
    """, (domainid, loguid))
    rs = list(rs)
    if not rs:
        raise Unauthorized("You are not admin of {}".format(domain))

def need_repo_id(domain, repo):
    rs = conn.execute("""
        SELECT R.id
        FROM   repo R JOIN domain D On R.domainid = D.id
        WHERE  R.name = ? AND D.name = ?
    """, (repo, domain))
    rs = list(rs)
    if not rs:
        raise GAError("repo does not exist: {}/{}".format(domain, repo))
    return rs[0][0]

def need_read_permission(domain, repo):
    repoid = need_repo_id(domain, repo)
    rs = conn.execute("""
        SELECT 1
        FROM permissions P
        WHERE P.repoid = ? AND P.userid = ?
    """, (repoid, loguid))
    rs = list(rs)
    if not rs:
        raise Unauthorized("You don't have permission to read from {}/{}"
                           .format(domain, repo))

def need_write_permission(domain, repo):
    repoid = need_repo_id(domain, repo)
    rs = conn.execute("""
        SELECT 1
        FROM   permissions P
        WHERE  P.repoid = ? AND P.userid = ? AND P.mode = 1
    """, (repoid, loguid))
    rs = list(rs)
    if not rs:
        raise Unauthorized("You don't have permission to write to {}/{}"
                           .format(domain, repo))

def warn_unadministered_domains():
    rs = conn.execute("""
        SELECT D.name
        FROM   domain D
        WHERE  NOT EXISTS (SELECT 1
                           FROM admin A
                           WHERE D.id = A.domainid)
    """)
    for r in rs:
        print("WARNING: Domain has no admin: {}".format(r[0]), file=sys.stderr)

def transaction(cmd):
    def func(*args, **kwargs):
        conn.execute('BEGIN TRANSACTION')
        try:
            try:
                r = cmd(*args, **kwargs)
            except sqlite3.IntegrityError as e:
                raise GAError(
                    'The database issued an integrity constraint error. '
                    'If you tried to delete data, that probably means that '
                    'there are leftover dependencies. '
                    'If you tried to input data, that probably means that '
                    'such an entry already exists. The database error was: {}'
                    .format(e)
                )
        except Exception as e:
            conn.execute('ROLLBACK')
            raise
        conn.execute('COMMIT')
        return r
    return func

def install_docmd(cmd):
    def func(self, x):
        return exec_cmdline('{} {}'.format(cmd.__name__, x))
    setattr(GitAdminShell, 'do_' + cmd.__name__, func)

def sucmd(cmd):
    install_docmd(cmd)
    def func(*args, **kwargs):
        need_is_root()
        return cmd(*args, **kwargs)
    root_cmds[cmd.__name__] = func

def rootcmd(cmd):
    install_docmd(cmd)
    @transaction
    def func(*args, **kwargs):
        need_is_root()
        return cmd(*args, **kwargs)
    root_cmds[cmd.__name__] = func

def domaincmd(cmd):
    install_docmd(cmd)
    @transaction
    def func(domain, *args, **kwargs):
        need_domain_id(domain)
        need_is_domain_admin(domain)
        return cmd(domain, *args, **kwargs)
    domain_cmds[cmd.__name__] = func

def usercmd(cmd):
    install_docmd(cmd)
    @transaction
    def func(*args, **kwargs):
        return cmd(*args, **kwargs)
    user_cmds[cmd.__name__] = func

def dflcmd(cmd):
    install_docmd(cmd)
    @transaction
    def func(*args, **kwargs):
        return cmd(*args, **kwargs)
    user_cmds[cmd.__name__] = func

@dflcmd
def info():
    print(shell_usage)

@usercmd
def whoami():
    print(loguser)

@usercmd
def domains():
    if is_root:
        rs = conn.execute("""
            SELECT D.name
            FROM   domain D
        """)
    else:
        rs = conn.execute("""
            SELECT D.name
            FROM   domain D JOIN Admin A ON D.id = A.domainid
            WHERE  A.userid = ?
        """, (loguid,))
    for r in rs:
        print(*r)

@usercmd
def perms():
    rs = conn.execute("""
        SELECT
                D.name,
                R.name,
                U.name,
                CASE WHEN mode=0 THEN "R" ELSE "RW" END
        FROM
                domain D
                JOIN repo R
                  ON D.id = R.domainid
                JOIN permissions P
                  on R.id = P.repoid
                JOIN user U
                  on P.userid = U.id
        WHERE
                U.id = ?
    """, (loguid,))
    for r in rs:
        print('\t'.join(r))

@usercmd
def sshkeys():
    rs = conn.execute("""
        SELECT S.algo, S.key, S.comment
        FROM   sshkey S
        WHERE  S.userid = ?
    """, (loguid,))
    for r in rs:
        print(' '.join(r))

@usercmd
def add_sshkey():
    if is_root:
        raise GAError("You are the root admin; refusing to add an SSH key")
    if is_interactive:
        print('Please give the key which you want added on one line',
              file=sys.stderr)
    line = sys.stdin.readline()
    algo, key, comment = need_valid_sshkey(line)
    try:
        conn.execute('INSERT INTO sshkey (userid, algo, key, comment) '
                     'VALUES (?, ?, ?, ?)', (loguid, algo, key, comment))
    except sqlite3.IntegrityError as e:
        raise GAError("Couldn't add ssh key. That probably means this key is "
                      "already in the database. The DB error: {}".format(e))
    else:
        write_ssh_authorized_keys()

@usercmd
def remove_sshkey():
    if is_interactive:
        print("Please give the key which you want removed on one line, "
              "just as returned by 'sshkeys'", file=sys.stderr)
    line = sys.stdin.readline()
    algo, key, _ = need_valid_sshkey(line)
    conn.execute('DELETE FROM sshkey '
                 'WHERE userid = ? AND algo = ? AND key = ?',
                 (loguid, algo, key))
    rs = conn.execute('SELECT total_changes()')
    rs = list(rs)
    if rs[0][0]:
        write_ssh_authorized_keys()

@domaincmd
def admins(domain):
    domainid = need_domain_id(domain)
    rs = conn.execute("""
        SELECT
                D.name,
                U.name
        FROM
                admin A
                JOIN domain D
                  ON A.domainid = D.id
                JOIN user U
                  ON A.userid = U.id
        WHERE
                D.id = ?
    """, (domainid,))
    for r in rs:
        print('{}\t{}'.format(*r))

@domaincmd
def repos(domain):
    domainid = need_domain_id(domain)
    rs = conn.execute("""
        SELECT R.name
        FROM   repo R
        WHERE  R.domainid = ?
    """, (domainid,))
    for r in rs:
        print(r[0])

@domaincmd
def repo_perms(domain, repo):
    domainid = need_domain_id(domain)
    repoid = need_repo_id(domain, repo)
    rs = conn.execute("""
        SELECT
                D.name || "/" || R.name,
                U.name,
                CASE WHEN mode=0 THEN "R" ELSE "RW" END
        FROM
                domain D
                JOIN repo R
                  ON D.id = R.domainid
                JOIN permissions P
                  ON R.id = P.repoid
                JOIN user U
                  ON P.userid = U.id
        WHERE
                R.id = ?
    """, (repoid,))
    for r in rs:
        print('\t'.join(r))

@domaincmd
def create_repo(domain, repo):
    domainid = need_domain_id(domain)
    need_valid_reponame(repo)
    try:
        conn.execute('INSERT INTO repo (domainid, name) '
                     'VALUES (?, ?)', (domainid, repo))
    except sqlite3.IntegrityError as e:
        raise GAError(
            "Failed to create repo. Probably a repo with this name "
            "already exists in this domain. DB error was: {}".format(e)
        )
    create_repo_git(domain, repo)

@domaincmd
def delete_repo(domain, repo):
    repoid = need_repo_id(domain, repo)
    conn.execute('DELETE FROM permissions WHERE repoid = ?', (repoid,))
    conn.execute('DELETE FROM repo WHERE id = ?', (repoid,))
    delete_repo_git(domain, repo)

@domaincmd
def set_domain_admin(domain, user):
    if user == 'root':
        print("No need to make the root admin a domain admin", file=sys.stderr)
        return
    domainid = need_domain_id(domain)
    userid = need_user_id(user)
    conn.execute('INSERT OR IGNORE INTO admin (domainid, userid) '
                 'VALUES (?, ?)', (domainid, userid))

@domaincmd
def unset_domain_admin(domain, user):
    domainid = need_domain_id(domain)
    userid = need_user_id(user)
    conn.execute('DELETE FROM admin WHERE domainid = ? AND userid = ?',
                 (domainid, userid))

@domaincmd
def set_perm(domain, repo, user, perm):
    if user == 'root':
        print("No need to add permissions for the root admin", file=sys.stderr)
        return
    repoid = need_repo_id(domain, repo)
    userid = need_user_id(user)
    mode = { 'none': -1, 'R': 0, 'RW': 1 }.get(perm)
    if mode is None:
        raise InvalidArgument("Permissions must be one of none, R or RW")
    if mode == -1:
        conn.execute('DELETE FROM permissions '
                     'WHERE repoid = ? AND userid = ?', (repoid, userid))
    else:
        conn.execute('INSERT OR REPLACE INTO permissions (repoid,userid,mode) '
                     'VALUES (?, ?, ?)', (repoid, userid, mode))

@rootcmd
def users():
    rs = conn.execute("""
        SELECT U.id, U.name, U.fullname
        FROM   user U
    """)
    for r in rs:
        print('{}\t{}\t{}'.format(*r))

@sucmd
def su(user, *args):
    userid = need_user_id(user)
    global loguser
    global loguid
    global is_root
    global stored_loguser
    global stored_loguid
    stored_loguser = loguser
    stored_loguid = loguid
    loguser = user
    loguid = userid
    is_root = loguser == 'root'
    try:
        exec_cmd_array(args)
    finally:
        loguser = stored_loguser
        loguid = stored_loguid
        is_root = loguser == 'root'

@rootcmd
def create_domain(domain, fullname):
    need_valid_domainname(domain)
    conn.execute('INSERT INTO domain (name, fullname) '
                 'VALUES (?, ?)', (domain, fullname))
    create_domain_dir(domain)

@rootcmd
def delete_domain(domain):
    domainid = need_domain_id(domain)
    conn.execute('DELETE FROM admin WHERE domainid = ?', (domainid,))
    try:
        conn.execute('DELETE FROM domain WHERE id = ?', (domainid,))
    except sqlite3.IntegrityError as e:
        raise GAError('Database integrity error. That probably means that '
                      'this domain has still repositories in it. DB error: {}'
                      .format(e))
    delete_domain_dir(domain)

@rootcmd
def create_user(user, fullname):
    need_valid_username(user)
    conn.execute('INSERT INTO user (name, fullname) '
                 'VALUES (?, ?)', (user, fullname))

@rootcmd
def delete_user(user):
    if (user == 'root'):
        print('WARNING: Refusing to delete root user', file=sys.stderr)
        return
    userid = need_user_id(user)
    conn.execute('DELETE FROM sshkey WHERE userid = ?', (userid,))
    conn.execute('DELETE FROM admin WHERE userid = ?', (userid,))
    conn.execute('DELETE FROM permissions WHERE userid = ?', (userid,))
    conn.execute('DELETE FROM user WHERE id = ?', (userid,))
    warn_unadministered_domains()
    write_ssh_authorized_keys()

def git_receive_pack(domain, repo):
    need_write_permission(domain, repo)
    path = repo_dirpath(domain, repo)
    subprocess.call(['git-receive-pack', path])

def git_upload_pack(domain, repo):
    need_read_permission(domain, repo)
    path = repo_dirpath(domain, repo)
    subprocess.call(['git-upload-pack', path])

def exec_cmd_array(cmd):
    name, arguments = cmd[0], cmd[1:]
    if name in root_cmds:
        func = root_cmds[name]
    elif name in domain_cmds:
        func = domain_cmds[name]
    elif name in user_cmds:
        func = user_cmds[name]
    else:
        raise InvalidArgument("No such command: {}".format(name))
    try:
        return func(*arguments)
    except TypeError:
        # for now, let's hope this is true
        # using inspection before calling func would be overkill
        raise InvalidArgument("wrong number of arguments")

def split_cmdline(cmdline):
    cmdline = cmdline.strip()
    cmd = []
    word = ""
    quoted = False
    escaped = False
    for char in cmdline:
        if escaped:
            word += char
            escaped = False
        elif char == '\\':
            escaped = True
        elif char == '"':
            quoted = not quoted
        # XXX: .isspace() supports locales. (good thing?)
        elif char.isspace() and not quoted:
            cmd.append(word)
            word = ""
        else:
            word += char
    if quoted:
        raise InvalidArgument("Unterminated quote in command line {}"
                              .format(cmdline))
    if escaped:
        raise InvalidArgument("Trailing escape character in command line {}"
                              .format(cmdline))
    if word:
        cmd.append(word)
    return cmd

def exec_cmdline(cmdline):
    cmd_array = split_cmdline(cmdline)
    return exec_cmd_array(cmd_array)

def exec_git_cmdline(ssh_original_command):
    # probably git-* will recognize 8bit unclean streams themselves...
    #need_8bitclean()
    regex = r"({}|{}) '({})/({})'".format(
        'git-receive-pack', 'git-upload-pack', domainname_regex, reponame_regex
    )
    m = exact_match(regex, ssh_original_command)
    if m is None:
        raise InvalidArgument(
            "Got {}, but only\n"
            "\tgit-receive-pack 'DOMAIN/REPO'\n"
            "\tgit-upload-pack  'DOMAIN/REPO'\n"
            "are allowed commands (DOMAIN and REPO must be valid names)."
            .format(ssh_original_command)
        )
    cmd, domain, repo = m.groups()
    if cmd == 'git-receive-pack':
       git_receive_pack(domain, repo)
    elif cmd == 'git-upload-pack':
       git_upload_pack(domain, repo)

def initialize_gitadmin_environment():
    basedir_exists = os.path.isdir(basedir_filepath())
    basedir_empty = not basedir_exists or not os.listdir(basedir_filepath())
    database_exists = os.path.isfile(database_filepath())
    authorized_keys_exists = os.path.isfile(authorized_keys_filepath())
    if not basedir_exists or not basedir_empty:
        raise GAError('The basedir {} does not exist or is not empty. '
                      'Refusing to initialize'.format(basedir_filepath()))
    if authorized_keys_exists:
        raise GAError('authorized_keys file {} exists. Refusing to initialize'
                      .format(authorized_keys_filepath()))
    if database_exists:
        raise GAError('Database {} exists. Refusing to initialize.'
                      .format(database_filepath()))
    create_repos_dir()
    create_authorized_keys()
    create_database()

def run_cmdstring_shell(cmdstring):
    global is_interactive
    is_interactive = False
    for line in cmdstring.splitlines():
        exec_cmdline(line)

def run_interactive_stdin_shell():
    global is_interactive
    is_interactive = True
    if is_root:
        print("Starting root admin shell...")
    GitAdminShell().cmdloop()

def run_noninteractive_stdin_shell():
    global is_interactive
    is_interactive = False
    for line in sys.stdin:
        exec_cmdline(line)

def login_user(user):
    global loguser
    global loguid
    global is_root
    loguser = 'root'
    loguid = 0
    loguid = need_user_id(user)
    loguser = user
    is_root = loguser == 'root'

def need_dbconn(cmd):
    def func(req_user, *args, **kwargs):
        connect_database()
        if req_user is None:
            login_user('root')
        else:
            login_user(req_user)
        r = cmd(*args, **kwargs)
        disconnect_database()
        return r
    return func

def process_help_request():
    print(long_usage)

def process_init_request():
    global is_interactive
    is_interactive = False
    initialize_gitadmin_environment()

@need_dbconn
def process_cmd_array(cmd_array):
    global is_interactive
    is_interactive = is_stdin_tty and is_stdout_tty and is_stderr_tty
    exec_cmd_array(cmd_array)

@need_dbconn
def process_cmd_string(cmd_string):
    global is_interactive
    is_interactive = False
    run_cmdstring_shell(cmd_string)

@need_dbconn
def process_stdin():
    # other shells test only stdin and stderr. But Cmd.cmd prints prompts to
    # stdout instead of stderr (can we fix that?), so redirecting from a shell
    # with command substitution, so for example, after "x=$(gitadmin whoami)"
    # contains not only a username but also the prompts.
    # For that reason we test also whether stdout is a tty, to run a
    # noninteractive shell if we are being run inside a command substitution.
    if is_stdin_tty and is_stdout_tty and is_stderr_tty:
        run_interactive_stdin_shell()
    else:
        run_noninteractive_stdin_shell()

@need_dbconn
def process_ssh_original_command(ssh_original_command):
    global is_interactive
    # currently only git supported
    exec_git_cmdline(ssh_original_command)

def gitadmin(argv, ssh_original_command):
    argv = argv[1:]
    wantinit = None
    wanthelp = None
    req_user = None
    cmd_string = None
    cmd_array = None
    if len(argv) >= 1 and argv[0] == '--init':
        wantinit = ()
        argv = argv[1:]
    if len(argv) >= 1 and argv[0] == '--help':
        wanthelp = ()
        argv = argv[1:]
    if len(argv) >= 2 and argv[0] == '-u':
        req_user = argv[1]
        argv = argv[2:]
    if len(argv) >= 2 and argv[0] == '-c':
        cmd_string = argv[1]
        argv = argv[2:]
    if len(argv) and not argv[0].startswith('-'):
        cmd_array = argv.copy()
        argv = []

    def wrong_usage():
        print(short_usage, file=sys.stderr)
        sys.exit(1)
    def exclusive(*opts):
        notnone = [o for o in opts if o is not None]
        if len(notnone) > 1:
            wrong_usage()
    if len(argv):
        wrong_usage()
    exclusive(wantinit, wanthelp, cmd_array, cmd_string)
    exclusive(wantinit, wanthelp, cmd_array, req_user)

    if wanthelp is not None:
        process_help_request()
    elif wantinit is not None:
        process_init_request()
    elif cmd_array is not None:
        process_cmd_array(req_user, cmd_array)
    elif cmd_string is not None:
        process_cmd_string(req_user, cmd_string)
    elif ssh_original_command is None:
        process_stdin(req_user)
    else:
        process_ssh_original_command(req_user, ssh_original_command)

def main(argv, ssh_original_command=None):
    try:
        gitadmin(argv, ssh_original_command)
    except GAError as e:
        print('gitadmin:', e, file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print('gitadmin: Unexpected error:', e, file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt as e:
        print('Keyboard interrupt', file=sys.stderr)

if __name__ == '__main__':
    main(sys.argv, os.getenv('SSH_ORIGINAL_COMMAND'))
