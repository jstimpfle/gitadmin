#!/usr/bin/env python3

import itertools
import os
import re
import readline, cmd
import sqlite3
import subprocess
import sys

config = {
  'basedir': 'gitadmin-basedir'
}

short_usage = r"""
gitadmin invocation:

    gitadmin --help
    gitadmin --init
    gitadmin [-u USER] ARGS...
    gitadmin [-u USER] -c COMMAND
    gitadmin [-u USER]
    SSH_ORIGINAL_CMD=GITCMD gitadmin [-u USER]
"""

long_usage = short_usage + r"""
In the first case, print this help message.

In the second case, initialize a new gitadmin environment. gitadmin will abort
if an existing environment is found. The base directory 'gitadmin-basedir' (or
whatever was configured by changing the program code) must exist, and be empty.
Filepath customization is currently done after initialization by moving the
objects which were created in the base directory somewhere else, and putting
symlinks into the base directory.

In the third case, the argument list is interpreted as a single gitadmin command
(possible commands are listed by the "info" command). If -u USER is given,
interpret the command as this gitadmin user. The arguments must form a pre-split
valid gitadmin command. For example, a valid invocation from the shell (sh)
would be

    $ gitadmin create_user john "John Doe"

In the fourth case, run the gitadmin shell in noninteractive mode, interpreting
COMMAND which must be a gitadmin shell command (a single argument). The gitadmin
shell syntax is explained a little in the next paragraph. If -u USER is given,
run as the given gitadmin user. Example gitadmin invocation from sh:

    $ gitadmin -u john -c 'set_perm john testrepo jane RW'

In the fifth case, run the gitadmin shell, interpreting commands read from
stdin. The shell is run in interactive mode if all standard streams are
connected to a tty, and otherwise in noninteractive mode. If -u USER is given,
run the shell as this gitadmin user. Commands are read line by line, and split
into words with a simple algorithm involving quotation mark (") as quote
character and backslash (\) as escape character, similar to the quoting
algorithm known from sh. Example: This\ is" all one "word. Example gitadmin
commands:

    gitadmin> create_repo john testrepo "John's testrepo, in domain \"john\""
    gitadmin> set_perm john testrepo john RW
    gitadmin> set_perm john testrepo jane R

(The "gitadmin> " prompts are printed by gitadmin in interactive mode, to
indicate that it is waiting for the next command).

In the sixth case, validate the environment variable SSH_ORIGINAL_CMD as an
allowed git request (git-receive-pack 'DOMAIN/REPO' or git-upload-pack
'DOMAIN/REPO', as can be observed with the git reference implementation) and
execute it as a subprocess, if the requesting user has appropriate permission.
This allows the actual git traffic, like pushes and pulls.
The idea is that the system administrator sets up a "gitadmin" system user, and
configures the "authorized_keys" file which is maintained by gitadmin as the
SshAuthorizedKeysFile for that system user.
"""

shell_intro = r"""
Welcome to gitadmin.

Type 'info' for a list of available commands
"""

shell_prompt = 'gitadmin> '

shell_usage = r"""
Root admin commands:

   su USER CMD...
   create_domain DOMAIN COMMENT
   delete_domain DOMAIN
   create_user USER COMMENT
   delete_user USER

Domain admin commands:                       User commands:

  admins DOMAIN                                info
  repos DOMAIN                                 whoami
  repo_perms DOMAIN REPO                       users
  set_domain_admin DOMAIN USER                 domains
  unset_domain_admin DOMAIN USER               perms
  create_repo DOMAIN REPO COMMENT              sshkeys
  delete_repo DOMAIN REPO                      add_sshkey
  set_repo_comment DOMAIN REPO COMMENT         remove_sshkey
  set_perm DOMAIN REPO USER <none|R|RW>        guests
  set_public DOMAIN REPO <true|false>          create_guest USER COMMENT
                                               delete_guest USER
"""

authorized_keys_header = r"""#
# THIS FILE IS MANAGED BY GITADMIN
#
"""

sqlschema = r"""
CREATE TABLE domain
( id INTEGER PRIMARY KEY
, name VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, UNIQUE (name)
);

CREATE TABLE user
( id INTEGER PRIMARY KEY
, host INTEGER REFERENCES user(id)
, name VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, UNIQUE (name)
);

CREATE TABLE repo
( id INTEGER PRIMARY KEY
, domainid INTEGER NOT NULL
, name VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, FOREIGN KEY (domainid) REFERENCES domain(id)
, UNIQUE (domainid, name)
);

CREATE TABLE permissions
( repoid INTEGER NOT NULL
, userid INTEGER NOT NULL
, mode INTEGER NOT NULL CHECK (mode = 0 or mode = 1)
--
, FOREIGN KEY (repoid) REFERENCES repo(id)
, FOREIGN KEY (userid) REFERENCES user(id)
, UNIQUE (repoid, userid)
);

CREATE TABLE admin
( domainid INTEGER NOT NULL
, userid INTEGER NOT NULL
--
, FOREIGN KEY (domainid) REFERENCES domain(id)
, FOREIGN KEY (userid) REFERENCES user(id)
, UNIQUE (domainid, userid)
);

CREATE TABLE sshkey
( id INTEGER PRIMARY KEY
, userid INTEGER NOT NULL
, algo VARCHAR NOT NULL
, key VARCHAR NOT NULL
, comment VARCHAR NOT NULL
--
, FOREIGN KEY (userid) REFERENCES user(id)
, UNIQUE (key)
);

CREATE TABLE publicro
( repoid INTEGER NOT NULL UNIQUE
--
, FOREIGN KEY (repoid) REFERENCES repo(id)
);

INSERT INTO user (id, name, comment) VALUES (0, "root", "");
"""

domainname_regex = r"""[abcdefghijklmnopqrstuvwxyz-]{2,16}"""
username_regex   = r"""(guest-)?[abcdefghijklmnopqrstuvwxyz0123456789]{2,16}"""
reponame_regex   = r"""[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-]{2,32}"""
domaincomment_regex = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
usercomment_regex   = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"#$%&'()*+../:;<=>@?[\^_`{|}~-]{0,255}"""
repocomment_regex   = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
algo_regex    = r"""(?:ssh-ed25519|ssh-rsa|ssh-dss|ecdsa-sha2-nistp256|ecdsa-sha2-nistp384|ecdsa-sha2-nistp521)"""
key_regex     = r"""[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/]{32,8192}={0,2}"""
comment_regex = r"""[]abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""


# **********************************************************************
# GLOBAL STATE
# **********************************************************************

# filled later when functions are defined
dfl_cmds = {}
user_cmds = {}
domain_cmds = {}
root_cmds = {}

# constants (after this initialization)
is_stdin_tty = os.isatty(sys.stdin.fileno())
is_stdout_tty = os.isatty(sys.stdout.fileno())
is_stderr_tty = os.isatty(sys.stderr.fileno())
# this will remain constant after initialization in main()
is_interactive = None
# these are set when the database connection is made
# (=> not for --help and --init run modes)
# They remain constant once set, except they might be temporarily swapped by
# "su"
loguser = None
loguid = None
is_root = False
stored_loguser = None
stored_loguid = None
# database connection
conn = None

# **********************************************************************
# END GLOBAL STATE
# **********************************************************************

class GAError(Exception):
    """Expected error conditions in gitadmin"""
    pass

class InvalidArgument(GAError):
    def __str__(self):
        return "Invalid Argument: {}".format(*self.args)

class Unauthorized(GAError):
    def __str__(self):
        return "Permission denied: {}".format(*self.args)

def basedir_filepath():
    return config['basedir']

def authorized_keys_filepath():
    base = basedir_filepath()
    return os.path.join(base, 'authorized_keys')

def database_filepath():
    base = basedir_filepath()
    return os.path.join(base, 'gitadmin.sqlite3')

def repos_dirpath():
    base = basedir_filepath()
    return os.path.join(base, 'repos')

def domain_dirpath(domain):
    base = repos_dirpath()
    return os.path.join(base, domain)

def repo_dirpath(domain, repo):
    dirpath = domain_dirpath(domain)
    return os.path.join(dirpath, repo) + '.git'

def repo_comment_filepath(domain, repo):
    dirpath = repo_dirpath(domain, repo)
    return os.path.join(dirpath, 'description')

def publicro_dirpath():
    dirpath = basedir_filepath()
    return os.path.join(dirpath, 'publicro')

def publicro_domain_dirpath(domain):
    dirpath = publicro_dirpath()
    return os.path.join(dirpath, domain)

def publicro_repo_dirpath(domain, repo):
    dirpath = publicro_domain_dirpath(domain)
    return os.path.join(dirpath, repo)

def create_repos_dir():
    dirpath = repos_dirpath()
    os.mkdir(dirpath)

def create_publicro_dir():
    dirpath = publicro_dirpath()
    os.mkdir(dirpath)

def create_authorized_keys():
    write_authorized_keys('')

def create_database():
    dbpath = database_filepath()
    c = sqlite3.connect(dbpath)
    c.isolation_level = None
    c.execute("PRAGMA FOREIGN_KEYS = ON")
    c.executescript(sqlschema)
    c.close()

def init_basedir():
    # some best-effort sanity checks before writing to the filesystem...
    basedir_exists = os.path.isdir(basedir_filepath())
    basedir_empty = not basedir_exists or not os.listdir(basedir_filepath())
    if not basedir_exists or not basedir_empty:
        raise GAError('The basedir {} does not exist or is not empty. '
                      'Refusing to initialize'.format(basedir_filepath()))
    create_repos_dir()
    create_publicro_dir()
    create_authorized_keys()
    create_database()

def create_domain_dir(domain):
    dirpath = domain_dirpath(domain)
    os.mkdir(dirpath)

def delete_domain_dir(domain):
    dirpath = domain_dirpath(domain)
    os.rmdir(dirpath)

def create_repo_git(domain, repo, comment=None):
    path = repo_dirpath(domain, repo)
    subprocess.call(["git", "init", "--bare", path])
    if comment is not None:
        set_repo_comment_git(domain, repo, comment)

def delete_repo_git(domain, reponame):
    path = repo_dirpath(domain, reponame)
    subprocess.call(["rm", "-rf", "--", path])

def set_repo_comment_git(domain, repo, comment):
    path = repo_comment_filepath(domain, repo)
    with open(path, 'w', encoding='utf-8') as f:
        f.write(comment)

def create_publicro_domain_dir(domain):
    dirpath = publicro_domain_dirpath(domain)
    os.mkdir(dirpath)

def delete_publicro_domain_dir(domain):
    dirpath = publicro_domain_dirpath(domain)
    os.rmdir(dirpath)

def connect_database():
    global conn
    dbpath = database_filepath()
    if not os.path.isfile(dbpath):
        raise GAError("Database doesn't exist. Call 'gitadmin --init'")
    conn = sqlite3.connect(dbpath)
    conn.isolation_level = None
    conn.execute("PRAGMA FOREIGN_KEYS = ON")

def disconnect_database():
    global conn
    conn.close()
    conn = None

def set_publicro_symlink(domain, repo):
    dirpath = repo_dirpath(domain, repo)
    linkpath = publicro_repo_dirpath(domain, repo)
    try:
        os.symlink(dirpath, linkpath)
    except OSError as e:
        raise GAError('Failed to create symlink: {}'.format(e))

def clear_publicro_symlink(domain, repo):
    linkpath = publicro_repo_dirpath(domain, repo)
    try:
        os.unlink(linkpath)
    except OSError as e:
        raise GAError('Failed to remove symlink: {}'.format(e))

def write_authorized_keys(contents):
    fpath = authorized_keys_filepath()
    tmp = fpath + ".tmp"
    with open(tmp, 'w', encoding='ascii') as f:
        f.write(authorized_keys_header)
        f.write(contents)
    os.rename(tmp, fpath)

def git_receive_pack(domain, repo):
    need_write_permission(domain, repo)
    path = repo_dirpath(domain, repo)
    subprocess.call(['git-receive-pack', path])

def git_upload_pack(domain, repo):
    need_read_permission(domain, repo)
    path = repo_dirpath(domain, repo)
    subprocess.call(['git-upload-pack', path])

def format_authorized_keys_line(user, algo, key, comment):
    return ("""command="gitadmin -u {}" {} {} {}\n"""
            .format(user, algo, key, comment))

def format_authorized_keys(rs):
    lines = [format_authorized_keys_line(*r) for r in rs]
    return ''.join(lines)

def format_table(rs):
    """Formats a list of lists of things nicely for the user
    Returns a list of strings (the rows formatted with matching colum widths)
    """
    lensll = [[len(c) for c in r] for r in rs]
    lensll = itertools.zip_longest(*lensll, fillvalue=0)
    collens = [max(lens) for lens in lensll]
    out = []
    def lalign(s, n):
        return s + (" " * (n - len(s)))
    for r in rs:
        cs = []
        for c, l in list(zip(r, collens))[:-1]:
            cs.append(lalign(str(c), l))
        for c in r[-1:]:
            cs.append(str(c))
        out.append('\t'.join(cs))
    return out

def exact_match(regex, x):
    return re.match(r'^' + regex + r'$', x)

def need_is_valid_domainname(x):
    if not exact_match(domainname_regex, x):
        raise InvalidArgument("'{}' is not a valid domain name".format(x))

def need_is_valid_domaincomment(x):
    if not exact_match(domaincomment_regex, x):
        raise InvalidArgument("'{}' is not a valid domain comment".format(x))

def need_is_valid_username(x):
    if not exact_match(username_regex, x):
        raise InvalidArgument("'{}' is not a valid user name".format(x))

def need_is_valid_guestname(x):
    need_is_valid_username(x)
    if not x.startswith('guest-'):
        raise InvalidArgument("'{}' ist not a valid guest user name:"
                              " must have \"guest-\" prefix".format(x))

def need_is_valid_usercomment(x):
    if not exact_match(usercomment_regex, x):
        raise InvalidArgument("'{}' is not a valid user comment".format(x))

def need_is_valid_reponame(x):
    if not exact_match(reponame_regex, x):
        raise InvalidArgument("'{}' is not a valid repo name".format(x))

def need_is_valid_repocomment(x):
    if not exact_match(repocomment_regex, x):
        raise InvalidArgument("'{}' is not a valid repo comment".format(x))

def need_is_valid_sshkey_algo(x):
    if not exact_match(algo_regex, x):
        raise InvalidArgument("'{}' is not a valid Sshkey algo".format(x))

def need_is_valid_sshkey_key(x):
    if not exact_match(key_regex, x):
        raise InvalidArgument("'{}' is not a valid Sshkey key".format(x))

def need_is_valid_sshkey_comment(x):
    if not exact_match(comment_regex, x):
        raise InvalidArgument("'{}' is not a valid Sshkey comment".format(x))

def need_is_root():
    if not is_root:
        raise Unauthorized("You are not root admin")

def need_is_domain_admin(domain):
    domainid = need_domain_id(domain)
    if is_root:
        return
    rs = conn.execute("""SELECT 1 FROM admin A
                         WHERE A.domainid = ? AND A.userid = ?""",
                      (domainid, loguid))
    rs = list(rs)
    if not rs:
        raise Unauthorized("You are not admin of {}".format(domain))

def need_is_native_user(user):
    rs = conn.execute("SELECT 1 FROM user WHERE name = ? and host IS NULL",
                      (user,))
    rs = list(rs)
    if not rs:
        raise Unauthorized("User {} is a guest user".format(user))

def need_is_host_of(host, guest):
    hostuid = need_user_id(host)
    guestuid = need_user_id(guest)
    rs = conn.execute("SELECT 1 FROM user WHERE id = ? and host = ?",
                      (guestuid, hostuid))
    rs = list(rs)
    if not rs:
        raise Unauthorized("User {} is not host of {}".format(host, guest))

def need_sshkey(x):
    words = x.split()
    if len(words) == 2:
        words.extend("")
    if len(words) != 3:
        raise Exception("Could not parse '{}' as an ssh key in the usual "
                        "OpenSSH key format: Need 3 words (algo, key, comment) "
                        " but got {}.".format(x, len(words)))
    need_is_valid_sshkey_algo(words[0])
    need_is_valid_sshkey_key(words[1])
    need_is_valid_sshkey_comment(words[2])
    return words

def need_domain_id(domain):
    need_is_valid_domainname(domain)  # XXX: not sure if this should be here
    rs = conn.execute("SELECT id FROM domain WHERE name = ?", (domain,))
    rs = list(rs)
    if not rs:
        raise GAError("domain does not exist: {}".format(domain))
    return rs[0][0]

def need_user_id(user):
    need_is_valid_username(user)
    rs = conn.execute("SELECT id FROM user WHERE name = ?", (user,))
    rs = list(rs)
    if not rs:
        raise GAError("user does not exist: {}".format(user))
    return rs[0][0]

def need_repo_id(domain, repo):
    need_is_valid_reponame(repo)
    rs = conn.execute("""SELECT R.id
                         FROM repo R JOIN domain D ON R.domainid = D.id
                         WHERE R.name = ? AND D.name = ?""", (repo, domain))
    rs = list(rs)
    if not rs:
        raise GAError("repo does not exist: {}/{}".format(domain, repo))
    return rs[0][0]

def need_read_permission(domain, repo):
    repoid = need_repo_id(domain, repo)
    rs = conn.execute("""SELECT 1 FROM permissions P
                         WHERE P.repoid = ? AND P.userid = ?""",
                      (repoid, loguid))
    rs = list(rs)
    if not rs:
        raise Unauthorized("You don't have permission to read from {}/{}"
                           .format(domain, repo))

def need_write_permission(domain, repo):
    repoid = need_repo_id(domain, repo)
    rs = conn.execute("""SELECT 1 FROM permissions P
                         WHERE P.repoid = ? AND P.userid = ? AND P.mode = 1""",
                      (repoid, loguid))
    rs = list(rs)
    if not rs:
        raise Unauthorized("You don't have permission to write to {}/{}"
                           .format(domain, repo))

def userinput_sshkey(prompt=None):
    """shared by add_sshkey(), remove_sshkey() and create_guest()"""
    if is_interactive and prompt is not None:
        print(prompt, file=sys.stderr)
    line = sys.stdin.readline()
    return need_sshkey(line)

def add_sshkey_db(uid, algo, key, comment):
    """shared by add_sshkey() and create_guest()"""
    try:
        conn.execute("""INSERT INTO sshkey (userid, algo, key, comment)
                        VALUES (?, ?, ?, ?)""", (uid, algo, key, comment))
    except sqlite3.IntegrityError as e:
        raise GAError("This key is already in the database")  # or user deleted
    else:
        update_ssh_authorized_keys()

def update_ssh_authorized_keys():
    ("""shared by add_sshkey_db(), remove_sshkey(), """
     """delete_user() and delete_guest()""")
    rs = conn.execute("""SELECT U.name, S.algo, S.key, S.comment
                         FROM user U JOIN sshkey S ON U.id = S.userid""")
    cts = format_authorized_keys(rs)
    write_authorized_keys(cts)

def add_user_db(name, comment, host=None):
    """shared by create_user() and create_guest()"""
    try:
        conn.execute("""INSERT INTO user (host, name, comment)
                        VALUES (?, ?, ?)""", (host, name, comment))
    except sqlite3.IntegrityError:
        raise GAError("User exists: {}".format(name))

def delete_user_db(uid):
    """shared by delete_user() and delete_guest()"""
    conn.execute("DELETE FROM admin WHERE userid = ?", (uid,))
    conn.execute("DELETE FROM permissions WHERE userid = ?", (uid,))
    conn.execute("DELETE FROM sshkey WHERE userid = ?", (uid,))
    conn.execute("DELETE FROM user WHERE id = ?", (uid,))
    rs = conn.execute(
        """SELECT D.name FROM domain D
           WHERE NOT EXISTS (SELECT 1 FROM admin A WHERE D.id = A.domainid)
           ORDER BY D.name""")
    for r in rs:
        print("WARNING: Domain has no admin: {}".format(r[0]), file=sys.stderr)

def split_cmdline(cmdline):
    cmdline = cmdline.strip()
    cmd = []
    word = ""
    started = False
    quoted = False
    escaped = False
    for char in cmdline:
        if escaped:
            word += char
            started = True
            escaped = False
        elif char == '\\':
            escaped = True
        elif char == '"':
            quoted = not quoted
            started = True
        elif char in [' ','\t'] and not quoted:
            if started:
                cmd.append(word)
            word = ""
            started = False
        else:
            word += char
            started = True
    if quoted:
        raise InvalidArgument("Unterminated quote: {}".format(cmdline))
    if escaped:
        raise InvalidArgument("Trailing escape character: {}".format(cmdline))
    if started:
        cmd.append(word)
    return cmd

def print_table(rs):
    rs = list(rs)
    if is_stdout_tty:
        for r in format_table(rs):
            print(r)
    else:
        for r in rs:
            print('\t'.join(str(c) for c in r))

# Sorry to say it, but cmd.Cmd is a pile of crap
class GitAdminShell(cmd.Cmd):
    intro = shell_intro
    prompt = shell_prompt

    @classmethod
    def install_docmd(cls, cmd):
        """install commands with this method to get tab completion for
         the command name"""
        def func(self, line):
            return exec_cmdline('{} {}'.format(cmd.__name__, line))
        setattr(cls, 'do_' + cmd.__name__, func)

    def __init__(self):
        # Override the bad decision to output prompts to sys.stdout.
        # The docs don't hint that the completekey default argument of 'Tab' is
        # really a string (!). Giving None instead doesn't restore the default
        # behaviour but instead disables completion -- but hey, that saved one
        # configuration option.
        super().__init__('Tab', sys.stdin, sys.stderr)

    # We need to override this method because the default is to repeat
    # the last command. Useful.
    def emptyline(self):
        pass

    # 'EOF' is used to indicate that the stdin stream has ended. A STRING. I'm
    # not making this up. And why do we need to handle this at all by default?
    def default(self, line):
        if line in ['EOF', 'exit', 'quit']:
            # On EOF, before exiting, end the line which the prompt started.
            if line == 'EOF':
                print()
            # indicate that the interpreter should be ended
            return True
        else:
            raise InvalidArgument("Couldn't parse command")

    # We must override this method to be able to handle exceptions from
    # executed commands
    def onecmd(self, line):
        try:
            # All commands should return None, except default() above where we
            # return True for EOF, exit, or quit
            return super().onecmd(line)
        except GAError as e:
            print("ERROR:", e, file=sys.stderr)
            return False

    # We must override this method because keyboard interrupts at the prompt
    # can't be handled in onecmd(). This will cost some stack space, but who
    # cares.
    def cmdloop(self):
        try:
            return super().cmdloop()
        except KeyboardInterrupt as e:
            # start a new line
            print()
            # before looping again, make sure intro won't be displayed again.
            self.intro = None
            return self.cmdloop()

    # By default, the built-in do_help command prints a barely useful
    # compilation of registered do_* commands. Turn that off.
    def do_help(self, line):
        return self.default(line)

def transaction(cmd):
    """Decorator used for most commands. Locks sqlite3 db globally"""
    def func(*args, **kwargs):
        conn.execute("BEGIN TRANSACTION")
        try:
            try:
                r = cmd(*args, **kwargs)
            except sqlite3.IntegrityError as e:
                # TODO: Ensure all expected database error conditions are
                # handled locally, and leave this error a non-GAError
                raise GAError(
                    "The database issued an integrity constraint error. "
                    "If you tried to delete data, that probably means that "
                    "there are leftover dependencies. "
                    "If you tried to input data, that probably means that "
                    "such an entry already exists. The database error was: {}"
                    .format(e))
        except:
            conn.execute("ROLLBACK")
            raise
        conn.execute("COMMIT")
        return r
    return func

def sucmd(cmd):
    GitAdminShell.install_docmd(cmd)
    def func(*args, **kwargs):
        need_is_root()
        return cmd(*args, **kwargs)
    root_cmds[cmd.__name__] = func

def rootcmd(cmd):
    GitAdminShell.install_docmd(cmd)
    @transaction
    def func(*args, **kwargs):
        need_is_root()
        return cmd(*args, **kwargs)
    root_cmds[cmd.__name__] = func

def domaincmd(cmd):
    GitAdminShell.install_docmd(cmd)
    @transaction
    def func(domain, *args, **kwargs):
        need_domain_id(domain)
        need_is_domain_admin(domain)
        return cmd(domain, *args, **kwargs)
    domain_cmds[cmd.__name__] = func

def usercmd(cmd):
    GitAdminShell.install_docmd(cmd)
    @transaction
    def func(*args, **kwargs):
        return cmd(*args, **kwargs)
    user_cmds[cmd.__name__] = func

def dflcmd(cmd):
    GitAdminShell.install_docmd(cmd)
    @transaction
    def func(*args, **kwargs):
        return cmd(*args, **kwargs)
    user_cmds[cmd.__name__] = func

# **********************************************************************
# GITADMIN COMMANDS
# **********************************************************************

@dflcmd
def info():
    print(shell_usage)

@usercmd
def whoami():
    print(loguser)

@usercmd
def users():
    rs = conn.execute("""SELECT U.name, U.comment FROM user U
                         WHERE U.name <> "root" """)
    print_table(rs)

@usercmd
def domains():
    if is_root:
        rs = conn.execute("""SELECT D.name, D.comment FROM domain D
                             ORDER BY D.name""")
    else:
        rs = conn.execute("""SELECT D.name, D.comment
                             FROM domain D JOIN Admin A ON D.id = A.domainid
                             WHERE A.userid = ?
                             ORDER BY D.name""", (loguid,))
    print_table(rs)

@usercmd
def perms():
    rs = conn.execute("""
        SELECT D.name, R.name, U.name, CASE WHEN P.mode=0 THEN "R" ELSE "RW" END
        FROM domain D
             JOIN repo R ON D.id = R.domainid
             JOIN permissions P on R.id = P.repoid
             JOIN user U on P.userid = U.id
        WHERE U.id = ?
        ORDER BY D.name, R.name""", (loguid,))
    print_table(rs)

@usercmd
def sshkeys():
    rs = conn.execute("""SELECT S.algo, S.key, S.comment
                         FROM sshkey S WHERE S.userid = ?""", (loguid,))
    for r in rs:
        print(' '.join(r))

@usercmd
def add_sshkey():
    if is_root:
        raise GAError("You are the root admin; refusing to add an SSH key")
    algo, key, comment = userinput_sshkey(
            "Please give the key which you want added on one line")
    add_sshkey_db(loguid, algo, key, comment)

@usercmd
def remove_sshkey():
    algo, key, _ = userinput_sshkey(
        "Please give the key which you want removed on one line, "
        "as returned by 'sshkeys'")
    conn.execute("""DELETE FROM sshkey
                    WHERE userid = ? AND key = ?""", (loguid, key))
    rs = conn.execute("SELECT changes()")
    rs = list(rs)
    if rs[0][0]:
        update_ssh_authorized_keys()
    else:
        print("WARNING: Key not found", file=sys.stderr)

@usercmd
def create_guest(guest, comment):
    need_is_native_user(loguser)
    need_is_valid_guestname(guest)
    need_is_valid_usercomment(comment)
    host = loguid
    add_user_db(host, guest, comment)
    uid = need_user_id(guest)
    algo, key, keycomment = userinput_sshkey(
        "You need to provide an initial public key for your guest")
    add_sshkey_db(uid, algo, key, keycomment)

@usercmd
def delete_guest(guest):
    need_is_native_user(loguser)
    need_is_valid_guestname(guest)
    need_is_host_of(loguser, guest)
    uid = need_user_id(guest)
    delete_user_db(uid)
    warn_unadministered_domains()
    update_ssh_authorized_keys()

@usercmd
def guests():
    rs = conn.execute("SELECT name, comment FROM user WHERE host = ?",
                      (loguid,))
    print_table(rs)

@domaincmd
def admins(domain):
    domainid = need_domain_id(domain)
    rs = conn.execute("""
        SELECT D.name, U.name
        FROM admin A
             JOIN domain D ON A.domainid = D.id
             JOIN user U ON A.userid = U.id
        WHERE D.id = ?
        ORDER BY U.name""", (domainid,))
    print_table(rs)

@domaincmd
def repos(domain):
    domainid = need_domain_id(domain)
    rs = conn.execute("""SELECT R.name, R.comment FROM repo R
                         WHERE R.domainid = ? ORDER BY R.name""", (domainid,))
    print_table(rs)

@domaincmd
def repo_perms(domain, repo):
    domainid = need_domain_id(domain)
    repoid = need_repo_id(domain, repo)
    rs = conn.execute("""
        SELECT D.name, R.name, U.name, CASE WHEN P.mode=0 THEN "R" ELSE "RW" END
        FROM domain D
             JOIN repo R ON D.id = R.domainid
             JOIN permissions P ON R.id = P.repoid
             JOIN user U ON P.userid = U.id
        WHERE R.id = ?
        ORDER BY U.name""", (repoid,))
    print_table(rs)

@domaincmd
def create_repo(domain, repo, comment):
    domainid = need_domain_id(domain)
    need_is_valid_reponame(repo)
    need_is_valid_repocomment(comment)
    try:
        conn.execute("""INSERT INTO repo (domainid, name, comment)
                        VALUES (?, ?, ?)""", (domainid, repo, comment))
    except sqlite3.IntegrityError:
        raise GAError("Repo exists: {}".format(repo))
    create_repo_git(domain, repo, comment)

@domaincmd
def delete_repo(domain, repo):
    repoid = need_repo_id(domain, repo)
    conn.execute("DELETE FROM publicro WHERE repoid = ?", (repoid,))
    conn.execute("DELETE FROM permissions WHERE repoid = ?", (repoid,))
    conn.execute("DELETE FROM repo WHERE id = ?", (repoid,))
    delete_repo_git(domain, repo)

@domaincmd
def set_repo_comment(domain, repo, comment):
    repoid = need_repo_id(domain, repo)
    need_is_valid_repocomment(comment)
    conn.execute("UPDATE repo SET comment = ? WHERE id = ?", (comment, repoid))
    set_repo_comment_git(domain, repo, comment)

@domaincmd
def set_domain_admin(domain, user):
    domainid = need_domain_id(domain)
    userid = need_user_id(user)
    if user == "root":
        print("No need to make the root admin a domain admin", file=sys.stderr)
    else:
        conn.execute("""INSERT OR IGNORE INTO admin (domainid, userid)
                        VALUES (?, ?)""", (domainid, userid))

@domaincmd
def unset_domain_admin(domain, user):
    domainid = need_domain_id(domain)
    userid = need_user_id(user)
    conn.execute("DELETE FROM admin WHERE domainid = ? AND userid = ?",
                 (domainid, userid))

@domaincmd
def set_perm(domain, repo, user, perm):
    repoid = need_repo_id(domain, repo)
    userid = need_user_id(user)
    mode = { "none": -1, "R": 0, "RW": 1 }.get(perm)
    if mode is None:
        raise InvalidArgument("Permissions must be one of none, R or RW")
    if user == "root":
        print("No need to add permissions for the root admin", file=sys.stderr)
    elif mode == -1:
        conn.execute("""DELETE FROM permissions
                        WHERE repoid = ? AND userid = ?""", (repoid, userid))
    else:
        conn.execute("""INSERT OR REPLACE INTO permissions (repoid,userid,mode)
                        VALUES (?, ?, ?)""", (repoid, userid, mode))

@domaincmd
def set_public(domain, repo, boolean):
    repoid = need_repo_id(domain, repo)
    publish = { 'true': True, 'false': False }.get(boolean)
    if publish is None:
        raise InvalidArgument("Usage: set_public <DOMAIN> <REPO> <true|false>")
    if publish:
        conn.execute("""INSERT OR IGNORE INTO publicro (repoid)
                        VALUES (?)""", (repoid,))
    else:
        conn.execute("DELETE FROM publicro WHERE repoid = ?", (repoid,))
    rs = conn.execute("SELECT changes()")
    rs = list(rs)
    if rs[0][0] != 0:
        if publish:
            set_publicro_symlink(domain, repo)
        else:
            clear_publicro_symlink(domain, repo)

@sucmd
def su(user, *args):
    global stored_loguser
    global stored_loguid
    global loguser
    global loguid
    global is_root
    userid = need_user_id(user)
    stored_loguser = loguser
    stored_loguid = loguid
    loguser = user
    loguid = userid
    is_root = loguser == "root"
    try:
        exec_cmd_array(args)
    finally:
        loguser = stored_loguser
        loguid = stored_loguid
        is_root = loguser == "root"

@rootcmd
def create_domain(domain, comment):
    need_is_valid_domainname(domain)
    need_is_valid_domaincomment(comment)
    try:
        conn.execute("""INSERT INTO domain (name, comment)
                        VALUES (?, ?)""", (domain, comment))
    except sqlite3.IntegrityError:
        raise GAError("Domain exists: {}".format(domain))
    create_domain_dir(domain)
    create_publicro_domain_dir(domain)

@rootcmd
def delete_domain(domain):
    domainid = need_domain_id(domain)
    conn.execute("DELETE FROM admin WHERE domainid = ?", (domainid,))
    try:
        conn.execute("DELETE FROM domain WHERE id = ?", (domainid,))
    except sqlite3.IntegrityError as e:
        raise GAError("Can't delete domain since it contains repositories")
    delete_domain_dir(domain)
    delete_publicro_domain_dir(domain)

@rootcmd
def create_user(user, comment):
    need_is_valid_username(user)
    need_is_valid_usercomment(comment)
    add_user_db(user, comment)

@rootcmd
def delete_user(user):
    if (user == "root"):
        print("WARNING: Refusing to delete root user", file=sys.stderr)
        return
    uid = need_user_id(user)
    delete_user_db(uid)
    warn_unadministered_domains()
    update_ssh_authorized_keys()

# **********************************************************************
# END GITADMIN COMMANDS
# **********************************************************************

def exec_cmd_array(cmd):
    name, arguments = cmd[0], cmd[1:]
    if name in root_cmds:
        func = root_cmds[name]
    elif name in domain_cmds:
        func = domain_cmds[name]
    elif name in user_cmds:
        func = user_cmds[name]
    else:
        raise InvalidArgument("No such command: {}".format(name))
    try:
        func(*arguments)
    except TypeError:
        # for now, let's hope this is true
        # using inspection before calling func would be overkill
        raise InvalidArgument("wrong number of arguments: {}".format(name))

def exec_cmdline(cmdline):
    cmd_array = split_cmdline(cmdline)
    if cmd_array:
        return exec_cmd_array(cmd_array)

def exec_git_cmdline(ssh_original_command):
    # probably git-* will recognize 8bit unclean streams themselves...
    #need_8bitclean()
    regex = r"({}|{}) '({})/({})'".format(
        'git-receive-pack', 'git-upload-pack', domainname_regex, reponame_regex)
    m = exact_match(regex, ssh_original_command)
    if m is None:
        raise InvalidArgument(
            "Invalid command: {}\n"
            "Only\n"
            "\tgit-receive-pack 'DOMAIN/REPO'\n"
            "\tgit-upload-pack  'DOMAIN/REPO'\n"
            "are allowed commands (DOMAIN and REPO must be valid names)."
            .format(ssh_original_command)
        )
    cmd, domain, repo = m.groups()
    if cmd == 'git-receive-pack':
       git_receive_pack(domain, repo)
    elif cmd == 'git-upload-pack':
       git_upload_pack(domain, repo)

def run_cmdstring_shell(cmdstring):
    for line in cmdstring.splitlines():
        exec_cmdline(line)

def run_interactive_stdin_shell():
    assert(is_interactive)
    if is_root:
        print("Starting root admin shell...")
    GitAdminShell().cmdloop()

def run_noninteractive_stdin_shell():
    assert(not is_interactive)
    for line in sys.stdin:
        exec_cmdline(line)

def login_user(user):
    global loguser
    global loguid
    global is_root
    loguser = "root"
    loguid = 0
    loguid = need_user_id(user)
    loguser = user
    is_root = loguser == "root"

def need_dbconn(cmd):
    """decorator used by the process_* functions (except help() and init())"""
    def func(req_user, *args, **kwargs):
        connect_database()
        if req_user is None:
            login_user("root")
        else:
            login_user(req_user)
        try:
            r = cmd(*args, **kwargs)
        finally:
            disconnect_database()
        return r
    return func

def process_help_request():
    global is_interactive
    is_interactive = False
    print(long_usage)

def process_init_request():
    global is_interactive
    is_interactive = False
    init_basedir()

@need_dbconn
def process_cmd_array(cmd_array):
    global is_interactive
    is_interactive = is_stdin_tty and is_stderr_tty
    exec_cmd_array(cmd_array)

@need_dbconn
def process_cmd_string(cmd_string):
    global is_interactive
    is_interactive = False
    run_cmdstring_shell(cmd_string)

@need_dbconn
def process_stdin():
    global is_interactive
    is_interactive = is_stdin_tty and is_stderr_tty
    if is_interactive:
        run_interactive_stdin_shell()
    else:
        run_noninteractive_stdin_shell()

@need_dbconn
def process_ssh_original_command(ssh_original_command):
    global is_interactive
    # currently only git supported
    exec_git_cmdline(ssh_original_command)

def gitadmin(argv, ssh_original_command):
    argv = argv[1:]
    wantinit = None
    wanthelp = None
    req_user = None
    cmd_string = None
    cmd_array = None
    if len(argv) >= 1 and argv[0] == '--init':
        wantinit = ()
        argv = argv[1:]
    if len(argv) >= 1 and argv[0] == '--help':
        wanthelp = ()
        argv = argv[1:]
    if len(argv) >= 2 and argv[0] == '-u':
        req_user = argv[1]
        argv = argv[2:]
    if len(argv) >= 2 and argv[0] == '-c':
        cmd_string = argv[1]
        argv = argv[2:]
    if len(argv) and not argv[0].startswith('-'):
        cmd_array = list(argv)
        argv = []

    def wrong_usage():
        print(short_usage, file=sys.stderr)
        sys.exit(1)
    def exclusive(*opts):
        notnone = [o for o in opts if o is not None]
        if len(notnone) > 1:
            wrong_usage()
    if len(argv):
        wrong_usage()
    exclusive(wantinit, wanthelp, cmd_array, cmd_string)
    exclusive(wantinit, wanthelp, req_user)

    if wanthelp is not None:
        process_help_request()
    elif wantinit is not None:
        process_init_request()
    elif cmd_array is not None:
        process_cmd_array(req_user, cmd_array)
    elif cmd_string is not None:
        process_cmd_string(req_user, cmd_string)
    elif ssh_original_command is None:
        process_stdin(req_user)
    else:
        process_ssh_original_command(req_user, ssh_original_command)

def main(argv, ssh_original_command=None):
    try:
        gitadmin(argv, ssh_original_command)
    except GAError as e:
        print("gitadmin:", e, file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print("gitadmin: Unexpected error:", e, file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("Keyboard interrupt", file=sys.stderr)

if __name__ == '__main__':
    main(sys.argv, os.getenv('SSH_ORIGINAL_COMMAND'))
