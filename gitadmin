#!/usr/bin/python3
# gitadmin - Copyright (C) 2015, Jens Stimpfle

import os, sys, re
import shlex
import sqlite3
import subprocess
import inspect
import readline, cmd

is_stdin_tty  = os.isatty(sys.stdin.fileno())
is_stdout_tty = os.isatty(sys.stdout.fileno())
is_stderr_tty = os.isatty(sys.stderr.fileno())

# *****************************************************************************
# Config
# *****************************************************************************

config_basedir = 'gitadmin-basedir'

# These can be tweaked. Additionally the following properties
# are checked for values that are meant to enter the DB:
#
# - repos and domains are filepath components (not '.' or '..',
#   no '/' or '\' allowed)
# - no whitespace allowed (good for scripting).
#   The exception are comments which can contains spaces
#   (comments always go in the last column)
#
# python3 doc says the character classes ([a-z] etc) are ASCII / C locale
username_regex        = r"""[a-z][a-z0-9]{0,14}"""
domainname_regex      = r"""[a-z][a-z0-9]{0,14}"""
reponame_regex        = r"""[a-zA-Z][a-zA-Z0-9_-]{0,30}"""
sshkey_keytype_regex  = r"""(?:ssh-ed25519|ssh-rsa|ssh-dss|ecdsa-sha2-nistp256|ecdsa-sha2-nistp384|ecdsa-sha2-nistp521)"""
sshkey_key_regex      = r"""[a-zA-Z0-9+/]{32,8192}={0,2}"""
sshkey_comment_regex  = r"""[]a-zA-Z0-9 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
userdesc_regex        = r"""[]a-zA-Z0-9 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
domaindesc_regex      = r"""[]a-zA-Z0-9 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""
repodesc_regex        = r"""[]a-zA-Z0-9 !"#$%&'()*+,./:;<=>@?[\^_`{|}~-]{0,255}"""

# *****************************************************************************
# Global state
# *****************************************************************************

# logged in or su'ed user
loguser = None

# database connection
conn = None

# *****************************************************************************
# Strings
# *****************************************************************************

help_short = r"""
gitadmin invocation:

    gitadmin --help
    gitadmin --init
    gitadmin [-u USER] ARGS...
    gitadmin [-u USER] -c CMD
    gitadmin [-u USER]
    SSH_ORIGINAL_COMMAND="git-receive-pack DOMAIN/REPO" gitadmin [-u USER]
    SSH_ORIGINAL_COMMAND="git-upload-pack DOMAIN/REPO" gitadmin [-u USER]
    SSH_ORIGINAL_COMMAND="gitadmin CMD" gitadmin [-u USER]
"""

help_long = help_short + r"""
gitadmin --help

    Print this help message.

gitadmin --init

    Initialize a new gitadmin environment. Gitadmin aborts if an
    existing environment is found.
    Filepaths can be customized after initialization by moving the
    files which were created in the base directory somewhere else,
    and putting symlinks into the base directory.

gitadmin [-u USER] ARGS...

    The argument list ARGS is interpreted as a (pre-split) gitadmin
    command. Possible commands are listed by the `help' command.
    If -u USER is given, interpret the command as this gitadmin user.
    For example, a valid invocation from the shell (sh) would be

        $ gitadmin create-user john "John Doe"

gitadmin [-u USER] -c CMD

    Run the gitadmin shell in noninteractive mode, interpreting CMD
    which must be a gitadmin shell command (a single argument).
    If -u USER is given, run as the given gitadmin user.
    Example gitadmin invocation from sh:

        $ gitadmin -u john -c 'set-perm john testrepo jane rw'

    Commands are split into words with a simple algorithm involving
    quotation mark (") as quote character and backslash (\) as escape
    character, similar to the quoting algorithm known from sh. Example:
    This\ is" all one "word.

    Example gitadmin commands:

        create-repo john testrepo "repo of \"John Doe\""
        set-perm john testrepo john rw
        set-perm john testrepo jane r

gitadmin [-u USER]

    Run the gitadmin shell, interpreting commands read from stdin.
    If -u USER is given, run the shell as this gitadmin user.
    If stdin and stderr are both connected to ttys the shell will
    be interactive (with command-line editing and history).

SSH_ORIGINAL_COMMAND="git-upload-pack DOMAIN/REPO" gitadmin [-u USER]
SSH_ORIGINAL_COMMAND="git-receive-pack DOMAIN/REPO" gitadmin [-u USER]

    Execute the git command given in the SSH_ORIGINAL_COMMAND
    environment variable (which is technically sh syntax; it is
    currently parsed using the python shlex module). The repo
    DOMAIN/REPO must exist in the database. If USER is given, this
    user must exist in the database and have read (git-upload-pack)
    or write (git-receive-pack) permission for the repo.
    This is used to make git over SSH work, with gitadmin as a
    transparent authentication and authorization layer. The idea is
    that the system administrator sets up a `gitadmin' system user,
    and uses the `authorized_keys' file which is maintained
    by gitadmin as SSH authentication method.
    Since the `authorized_keys' file has all lines prefixed with
    `command="gitadmin -u USER"', when an ssh client requests to run
    a command instead of an interactive shell, sshd will store the
    command originally sent by the client in SSH_ORIGINAL_COMMAND,
    and run `gitadmin -u USER'.

SSH_ORIGINAL_COMMAND="gitadmin CMD" gitadmin [-u USER]

    Like above, but run CMD which must be a gitadmin command.
    If USER is given, the command is run as that gitadmin user.
    This feature makes gitadmin commands conveniently accessible over
    SSH just like shell commands in regular SSH sessions:

        $ ssh git@HOST 'gitadmin CMD'

    Since the SSH_ORIGINAL_COMMAND is parsed using the python shlex
    module, this is slightly different from

        $ echo 'CMD' | ssh -T git@HOST

    which is read from stdin, and parsed using the simpler lexer also
    used in interactive gitadmin sessions.
"""

shell_intro = "Welcome to gitadmin. Type 'help' for a list of available commands"

shell_prompt = "gitadmin> "

commands_listing = r"""
 Root admin commands:

   su USER CMD...
   create-domain DOMAIN DESCRIPTION
   delete-domain DOMAIN
   set-domain-desc DOMAIN DESCRIPTION
   create-user USER DESCRIPTION
   delete-user USER
   set-user-desc USER DESCRIPTION

 Domain admin commands:

   list-repos DOMAIN
   create-repo DOMAIN REPO DESCRIPTION
   delete-repo DOMAIN REPO
   set-repo-desc DOMAIN REPO DESCRIPTION
   set-repo-public DOMAIN REPO <true|false>
   list-perms DOMAIN REPO
   set-perm DOMAIN REPO USER <none|r|rw>
   list-admins DOMAIN
   set-admin DOMAIN USER <true|false>

 User commands:

   help
   whoami
   list-users
   list-domains
   list-own-perms
   list-own-domains
   list-own-sshkeys
   add-own-sshkey KEYTYPE KEY COMMENT
   remove-own-sshkey
   list-own-guests
   create-own-guest USER DESCRIPTION KEYTYPE KEY COMMENT
   delete-own-guest USER
"""

sql_schema_version = "0.1"
sql_schema = r"""
CREATE TABLE gitadmin_metadata
( schema_version VARCHAR NOT NULL
);

CREATE TABLE user
( user VARCHAR NOT NULL
, desc VARCHAR NOT NULL
, PRIMARY KEY (user)
);

CREATE TABLE domain
( domain VARCHAR NOT NULL
, desc   VARCHAR NOT NULL
, PRIMARY KEY (domain)
);

CREATE TABLE repo
( domain VARCHAR NOT NULL
, repo   VARCHAR NOT NULL
, desc   VARCHAR NOT NULL
, PRIMARY KEY (domain, repo)
, FOREIGN KEY (domain) REFERENCES domain (domain)
);

CREATE TABLE sshkey
( user    VARCHAR NOT NULL
, keytype VARCHAR NOT NULL
, key     VARCHAR NOT NULL
, comment VARCHAR NOT NULL
, PRIMARY KEY (user, key)
, FOREIGN KEY (user) REFERENCES user (user)
);

CREATE TABLE admin
( domain VARCHAR NOT NULL
, user   VARCHAR NOT NULL
, PRIMARY KEY (domain, user)
, FOREIGN KEY (domain) REFERENCES domain (domain)
, FOREIGN KEY (user)   REFERENCES user   (user)
);

CREATE TABLE perm
( domain VARCHAR NOT NULL
, repo   VARCHAR NOT NULL
, user   VARCHAR NOT NULL
, perm   VARCHAR NOT NULL
, PRIMARY KEY (domain, repo, user)
, FOREIGN KEY (domain, repo) REFERENCES repo (domain, repo)
, FOREIGN KEY (user)         REFERENCES user (user)
, CHECK (perm == "r" OR perm == "rw")
);

CREATE TABLE publicro
( domain VARCHAR NOT NULL
, repo   VARCHAR NOT NULL
, PRIMARY KEY (domain, repo)
, FOREIGN KEY (domain, repo)   REFERENCES repo (domain, repo)
);

CREATE TABLE guest
( guest  VARCHAR NOT NULL
, host   VARCHAR NOT NULL
, PRIMARY KEY (guest, host)
, FOREIGN KEY (guest) REFERENCES user (user)
, FOREIGN KEY (host)  REFERENCES user (user)
);
"""

# *****************************************************************************
# Exceptions
# *****************************************************************************
# For clearer semantics, runtime exceptions are immediately converted
# to these custom exceptions.
#
# Any unconverted runtime exceptions are bugs, or are not cared about,
# like MemoryError.

class GA_Exception(Exception):
    def __str__(self):
        return "{}: {}".format(self.errcode, super().__str__())

class GA_FSError(GA_Exception):
    "Unexpected error from the filesystem or the OS"
    errcode = "FS-ERROR"

class GA_DBError(GA_Exception):
    "Unexpected error from the database or the OS"
    errcode = "DB-ERROR"

class GA_CLIError(GA_Exception):
    "Wrong command-line invocation"
    errcode = "COMMANDLINE-ERROR"

class GA_Invalid(GA_Exception):
    """gitadmin command could not be parsed, or wrong number of
    arguments, or some argument did not match the according regular
    expression"""
    errcode = "INVALID-COMMAND"

class GA_Unauthorized(GA_Exception):
    "A parsed command could not be authorized"
    errcode = "UNAUTHORIZED"

class GA_NotFound(GA_Exception):
    "An object reference could not be resolved"
    errcode = "NOT-FOUND"

class GA_Exists(GA_Exception):
    "Object could not be created because it already exists"
    errcode = "EXISTS"

class GA_FailedDependencies(GA_Exception):
    """Operation not carried out because some other operation needs
    to be performed first (like deleting all repos from a domain
    before the domain can be deleted)"""
    errcode = "FAILED-DEPENDENCIES"

# **********************************************************************
# Helper functions
# **********************************************************************

def exact_match(regex, value):
    return re.match(r'^' + regex + r'$', value) is not None

# When an FS operation is not successful for any reason, that's unexpected.
# Bail out (GA_FSError isn't handled anywhere).

def mkdir(dirpath):
    try:
        os.mkdir(dirpath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to create directory: {}".format(e)) from e

def rmdir(dirpath):
    try:
        os.rmdir(dirpath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to remove directory: {}".format(e)) from e

def symlink(filepath, linkpath):
    try:
        os.symlink(filepath, linkpath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to create symlink: {}".format(e)) from e

def unlink(filepath):
    try:
        os.unlink(filepath)
    except (IOError, OSError) as e:
        raise GA_FSError("Failed to unlink: {}".format(e)) from e

def write_file(filepath, rawbytes):
    try:
        with open(filepath, 'wb') as f:
            f.write(rawbytes)
    except (OSError, IOError) as e:
        raise GA_FSError("Failed to write file: {}".format(e)) from e

def create_git_repo(repopath):
    r = subprocess.call(["git", "init", "--bare", repopath])
    if r != 0:
        raise GA_FSError("Failed to create git repo: exitcode {} from \"git init --bare {}\"".format(r, repopath))

def delete_git_repo(repopath):
    r = subprocess.call(["rm", "-r", "--", repopath])
    if r != 0:
        raise GA_FSError("Failed to delete git repo: exitcode {} from \"rm -r -- {}".format(r, repopath))

# DB exceptions (like I/O errors, messed up database, or
# integrity errors resulting from program logic bugs) are unexpected.
# Bail out (GA_DBError isn't handled anywhere)

def create_db():
    if os.path.exists(path_database()):
        raise GA_DBError("Database exists")
    try:
        conn = sqlite3.connect(path_database(), isolation_level=None)
        conn.execute("PRAGMA FOREIGN_KEYS = ON")
        conn.executescript(sql_schema)
        conn.execute("INSERT INTO gitadmin_metadata (schema_version) VALUES (?)", (sql_schema_version,))
        conn.close()
    except sqlite3.Error as e:
        raise GA_DBError("Error creating Database: {}".format(e)) from e

def connect_db():
    global conn
    if not os.path.exists(path_database()):
        raise GA_DBError("Database doesn't exist. Call 'gitadmin --init'")
    try:
        conn = sqlite3.connect(path_database(), isolation_level=None)
        conn.execute("PRAGMA FOREIGN_KEYS = ON")
        rows = conn.execute("SELECT schema_version FROM gitadmin_metadata")
        if tuple(rows) != ((sql_schema_version,),):
            raise GA_DBError("Error opening Database: Wrong Database schema version. Probably gitadmin was upgraded and the DB needs migration")
    except sqlite3.Error as e:
        raise GA_DBError("Error opening Database: {}".format(e)) from e

def disconnect_db():
    global conn
    try:
        conn.close()
    except sqlite3.Error as e:
        raise GA_DBError("Error closing Database: {}".format(e)) from e
    conn = None

def begin_db_transaction():
    global conn
    try:
        conn.execute("BEGIN TRANSACTION")
    except sqlite3.Error as e:
        raise GA_DBError("Error starting DB transaction: {}".format(e)) from e

def end_db_transaction():
    global conn
    try:
        conn.execute("END TRANSACTION")
    except sqlite3.Error as e:
        raise GA_DBError("Error committing DB transaction: {}".format(e)) from e

def abort_db_transaction():
    global conn
    try:
        conn.execute("ROLLBACK")
    except sqlite3.Error as e:
        raise GA_DBError("Error while aborting DB transaction: {}".format(e)) from e

def select(sql, args=()):
    global conn
    try:
        rs = conn.execute(sql, args)
        return tuple(rs)
    except sqlite3.Error as e:
        raise GA_DBError("Error while executing DB command: {}".format(e)) from e

def exists(sql, args=()):
    global conn
    try:
        rs = conn.execute(sql, args)
        return bool(tuple(rs))
    except sqlite3.Error as e:
        raise GA_DBError("Error while executing DB command: {}".format(e)) from e

def insert(sql, args=()):
    global conn
    try:
        conn.execute(sql, args)
    except sqlite3.Error as e:
        raise GA_DBError("Error while executing DB command: {}".format(e)) from e

def delete(sql, args=()):
    global conn
    try:
        conn.execute(sql, args)
        rs = conn.execute("SELECT CHANGES()")
        return tuple(rs)[0][0]
    except sqlite3.Error as e:
        raise GA_DBError("Error while executing DB command: {}".format(e)) from e

def update(sql, args=()):
    global conn
    try:
        conn.execute(sql, args)
        rs = conn.execute("SELECT CHANGES()")
        return tuple(rs)[0][0]
    except sqlite3.Error as e:
        raise GA_DBError("Error while executing DB command: {}".format(e)) from e

def with_db(fun, *args):
    connect_db()
    try:
        return fun(*args)
    finally:
        disconnect_db()

def run_transaction(fun, *args):
    begin_db_transaction()
    try:
        r = fun(*args)
    except:
        abort_db_transaction()
        raise
    else:
        end_db_transaction()
        return r

# **********************************************************************
# Formatting
# **********************************************************************

def format_authorized_keys(rs):
    return ''.join('command="gitadmin -u {}" {} {} {}\n'.format(user, keytype, key, comment) for user, keytype, key, comment in rs)

def format_table(rs):
    lss = zip(*[[len(c) for c in r] for r in rs])
    ls = [max(ls) for ls in lss]
    xs = [[str(c).ljust(l) for c, l in tuple(zip(r, ls))[:-1]] + [r[-1]] for r in rs]
    return ''.join('  '.join(x) + '\n' for x in xs)

# **********************************************************************
# File paths
# **********************************************************************

def path_base_dir():
    return os.path.join(config_basedir)

def path_repos_dir():
    return os.path.join(config_basedir, 'repos')

def path_authorized_keys():
    return os.path.join(config_basedir, 'authorized_keys')

def path_database():
    return os.path.join(config_basedir, 'gitadmin.sqlite3')

def path_domain_dir(domain):
    return os.path.join(config_basedir, 'repos', domain)

def path_repo_dir(domain, repo):
    return os.path.join(config_basedir, 'repos', domain, repo)

def path_repodesc(domain, repo):
    return os.path.join(config_basedir, 'repos', domain, repo, 'description')

def path_publicro_dir():
    return os.path.join(config_basedir, 'publicro')

def path_publicro_domain_dir(domain):
    return os.path.join(config_basedir, 'publicro', domain)

def path_publicro_repo_symlink(domain, repo):
    return os.path.join(config_basedir, 'publicro', domain, repo)

# **********************************************************************
# File system
# **********************************************************************

def fs_initialize():
    mkdir(path_base_dir())
    mkdir(path_repos_dir())
    mkdir(path_publicro_dir())
    write_file(path_authorized_keys(), bytes('', 'UTF-8'))
    create_db()

def fs_make_domain_dir(domain):
    mkdir(path_domain_dir(domain))

def fs_remove_domain_dir(domain):
    rmdir(path_domain_dir(domain))

def fs_create_repo(domain, repo):
    create_git_repo(path_repo_dir(domain, repo))

def fs_delete_repo(domain, repo):
    delete_git_repo(path_repo_dir(domain, repo))

def fs_set_repo_desc(domain, repo, desc):
    write_file(path_repodesc(domain, repo), bytes(desc, 'UTF-8'))

def fs_make_publicro_domain_dir(domain):
    mkdir(path_publicro_domain_dir(domain))

def fs_remove_publicro_domain_dir(domain):
    rmdir(path_publicro_domain_dir(domain))

def fs_set_publicro_symlink(domain, repo):
    repopath = path_repo_dir(domain, repo)
    linkpath = path_publicro_repo_symlink(domain, repo)
    symlink(repopath, linkpath)

def fs_clear_publicro_symlink(domain, repo):
    linkpath = path_publicro_repo_symlink(domain, repo)
    unlink(linkpath)

def fs_write_authorized_keys(keys):
    data = ''.join("command=\"gitadmin -u {}\" {} {} {}\n".format(user, keytype, key, comment) for user, keytype, key, comment in keys)
    write_file(path_authorized_keys(), bytes(data, 'UTF-8'))

# **********************************************************************
# Database
# **********************************************************************
# Translate between the relational view of the database and the
# more object-oriented gitadmin view.
#
# - All functions assert that the references given as function arguments exist
#   (except where they are meant to be "created")
# - db_list_* are read-only. They return tuples of flat tuples (i.e, relations)
# - db_insert_* raise GA_Exists if the "object" to be inserted already exists.
# - db_delete_* raise GA_NotFound if the "object" to be deleted doesn't exist,
#   or GA_FailedDependencies if a precondition for deletion isn't fulfilled.
# - db_set_* and db_clear_* return None. They are idempotent. GA_NotFound is
#   raised when a referenced object doesn't exist.

def db_list_users():
    return select("SELECT user, desc FROM user ORDER BY user")

def db_list_guests():
    return select("SELECT user, desc FROM user, guest WHERE user = guest ORDER BY user, desc")

def db_list_sshkeys():
    return select("SELECT user, keytype, key, comment FROM sshkey ORDER BY user, keytype, key")

def db_list_domains():
    return select("SELECT domain, desc FROM domain ORDER BY domain")

def db_list_repos():
    return select("SELECT domain, repo, desc FROM repo ORDER BY domain, repo")

def db_list_admins():
    return select("SELECT domain, user FROM admin ORDER BY domain, user")

def db_list_perms_of_user(user):
    assert user is None or exists("SELECT 1 FROM user WHERE user = ?", (user,))
    return select("SELECT domain, repo, user, perm FROM perm WHERE user = ? ORDER BY domain, repo, user, perm", (user,))

def db_list_perms_of_repo(domain, repo):
    if not exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("Repo not found")
    return select("SELECT domain, repo, user, perm FROM perm WHERE domain = ? AND repo = ? ORDER BY domain, repo, user, perm", (domain, repo))

def db_list_perms_of_repo_and_user(domain, repo, user):
    assert user is None or exists("SELECT 1 FROM user WHERE user = ?", (user,))
    if not exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("Repo not found")
    return select("SELECT domain, repo, user, perm FROM perm WHERE domain = ? AND REPO = ? AND user = ? ORDER BY domain, repo, user, perm", (domain, repo, user))

def db_list_guests_of_user(user):
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    return select("SELECT user, desc FROM user, guest WHERE user = guest AND host = ? ORDER BY user, desc", (user,))

def db_list_sshkeys_of_user(user):
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    return select("SELECT user, keytype, key, comment FROM sshkey WHERE user = ? ORDER BY user, keytype, key", (user,))

def db_list_admins_of_domain(domain):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    return select("SELECT domain, user FROM admin WHERE domain = ? ORDER BY domain, user", (domain,))

def db_list_repos_of_domain(domain):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    return select("SELECT domain, repo, desc FROM repo WHERE domain = ? ORDER BY domain, repo, desc", (domain,))

def db_list_publicro_of_repo(domain, repo):
    if not exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("Repo not found")
    return select("SELECT domain, repo FROM publicro WHERE domain = ? AND repo = ?", (domain, repo))

def db_list_domains_of_user(user):
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    return select("SELECT domain, user FROM admin WHERE user = ? ORDER BY domain, user", (user,))

def db_insert_user(user, desc):
    if exists("SELECT 1 FROM user WHERE user = ?", (user,)):
        raise GA_Exists("User already exists")
    insert("INSERT INTO user (user, desc) VALUES (?, ?)", (user, desc))

def db_insert_domain(domain, desc):
    if exists("SELECT 1 FROM domain WHERE domain = ?", (domain,)):
        raise GA_Exists("Domain already exists")
    insert("INSERT INTO domain (domain, desc) VALUES (?, ?)", (domain, desc))

def db_insert_repo(domain, repo, desc):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    if exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_Exists("Repo already exists")
    insert("INSERT INTO repo (domain, repo, desc) VALUES (?, ?, ?)", (domain, repo, desc))

def db_insert_sshkey(user, keytype, key, comment):
    assert exists("SELECT 1 FROM user WHERE user = ?", (user,))
    if exists("SELECT 1 FROM sshkey WHERE key = ?", (key,)):
        raise GA_Exists("SSH key already registered")
    insert("INSERT INTO sshkey (user, keytype, key, comment) VALUES (?, ?, ?, ?)", (user, keytype, key, comment))

def db_delete_user(user):
    if not exists("SELECT 1 FROM user WHERE user = ?", (user,)):
        raise GA_NotFound("User not found")
    delete("DELETE FROM guest WHERE host = ?", (user,))
    delete("DELETE FROM sshkey WHERE user = ?", (user,))
    delete("DELETE FROM admin WHERE user = ?", (user,))
    delete("DELETE FROM perm WHERE user = ?", (user,))
    delete("DELETE FROM user WHERE user = ?", (user,))

def db_delete_domain(domain):
    if not exists("SELECT 1 FROM domain WHERE domain = ?", (domain,)):
        raise GA_NotFound("Domain not found")
    if exists("SELECT 1 FROM repo WHERE domain = ?", (domain,)):
        raise GA_FailedDependencies("Domain not empty")
    delete("DELETE FROM admin WHERE domain = ?", (domain,))
    delete("DELETE FROM domain WHERE domain = ?", (domain,))

def db_delete_repo(domain, repo):
    if not exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("Repo not found")
    delete("DELETE FROM publicro WHERE domain = ? AND repo = ?", (domain, repo))
    delete("DELETE FROM perm WHERE domain = ? AND repo = ?", (domain, repo))
    delete("DELETE FROM repo WHERE domain = ? AND repo = ?", (domain, repo))

def db_delete_sshkey(user, keytype, key):
    # (ignoring keytype)
    if not exists("SELECT 1 FROM sshkey WHERE user = ? AND key = ?", (user, key)):
        raise GA_NotFound("SSH key not found or not your key")
    delete("DELETE FROM sshkey WHERE user = ? AND key = ?", (user, key))

def db_update_user_desc(user, desc):
    if not exists("SELECT 1 FROM user WHERE user = ?", (user,)):
        raise GA_NotFound("No such user: {}".format(user))
    update("UPDATE user SET desc = ?", (user,))

def db_update_domain_desc(domain, desc):
    if not exists("SELECT 1 FROM domain WHERE domain = ?", (domain,)):
        raise GA_NotFound("No such domain: {}".format(domain))
    update("UPDATE domain SET desc = ? WHERE domain = ?", (desc, domain))

def db_update_repo_desc(domain, repo, desc):
    if not exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("No such repo: {} {}".format(domain, repo))
    update("UPDATE repo SET desc = ? WHERE domain = ? AND repo = ?", (desc, domain, repo))

def db_set_admin(domain, user):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    if not exists("SELECT 1 FROM user WHERE user = ?", (user,)):
        raise GA_NotFound("No such user: {}".format(user))
    insert("INSERT OR IGNORE INTO admin (domain, user) VALUES (?, ?)", (domain, user))

def db_clear_admin(domain, user):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    if not exists("SELECT 1 FROM user WHERE user = ?", (user,)):
        raise GA_NotFound("No such user: {}".format(user))
    delete("DELETE FROM admin WHERE domain = ? AND user = ?", (domain, user))

def db_set_perm(domain, repo, user, perm):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    assert perm in ['r','rw']
    if not exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("No such repo: {} {}".format(domain, repo))
    if not exists("SELECT 1 FROM user WHERE user = ?", (user,)):
        raise GA_NotFound("No such user: {}".format(user))
    delete("DELETE FROM perm WHERE domain = ? AND repo = ? AND user = ?", (domain, repo, user))
    insert("INSERT INTO perm (domain, repo, user, perm) VALUES (?, ?, ?, ?)", (domain, repo, user, perm))

def db_clear_perm(domain, repo, user):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    if not exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("No such repo: {} {}".format(domain, repo))
    if not exists("SELECT 1 FROM user WHERE user = ?", (user,)):
        raise GA_NotFound("No such user: {}".format(user))
    delete("DELETE FROM perm WHERE domain = ? AND repo = ? AND user = ?", (domain, repo, user))

def db_set_publicro(domain, repo):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    if not exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("No such repo: {} {}".format(domain, repo))
    delete("DELETE FROM publicro WHERE domain = ? AND repo = ?", (domain, repo))
    insert("INSERT INTO publicro (domain, repo) VALUES (?, ?)", (domain, repo))

def db_clear_publicro(domain, repo):
    assert exists("SELECT 1 FROM domain WHERE domain = ?", (domain,))
    if not exists("SELECT 1 FROM repo WHERE domain = ? AND repo = ?", (domain, repo)):
        raise GA_NotFound("No such repo: {} {}".format(domain, repo))
    delete("DELETE FROM publicro WHERE domain = ? AND repo = ?", (domain, repo))

def db_set_host(host, guest):
    assert exists("SELECT 1 FROM user WHERE user = ?", (guest,))
    assert exists("SELECT 1 FROM user WHERE user = ?", (host,))
    insert("INSERT INTO guest (guest, host) VALUES (?, ?)", (guest, host))

def db_clear_host(host, guest):
    assert exists("SELECT 1 FROM user WHERE user = ?", (guest,))
    assert exists("SELECT 1 FROM user WHERE user = ?", (host,))
    delete("DELETE FROM guest WHERE guest = ? AND host = ?", (guest, host))

# *****************************************************************************
# User input validation
# *****************************************************************************

def has_linebreaks(x):
    return '\n' in x or '\r' in x

def is_word(x):
    return len(x.split()) <= 1

def is_valid_filename(x):
    return len(x.split()) <= 1 and x not in ['.','..'] and '/' not in x and '\\' not in x

def need_valid_username(user):
    if not is_word(user) or not exact_match(username_regex, user):
        raise GA_Invalid("'{}' is not a valid user name".format(user))

def need_valid_guestname(user):
    if not user.startswith('guest-'):
        raise GA_Invalid("'{}' is not a valid guest user name (must start with guest-)".format(user))
    if not is_word(user) or not exact_match(r'guest-' + username_regex, user):
        raise GA_Invalid("'{}' is not a valid guest user name".format(user))

def need_valid_domainname(domain):
    if not is_valid_filename(domain) or not exact_match(domainname_regex, domain):
        raise GA_Invalid("'{}' is not a valid domain name".format(domain))

def need_valid_reponame(repo):
    if not is_valid_filename(repo) or not exact_match(reponame_regex, repo):
        raise GA_Invalid("'{}' is not a valid repo name".format(repo))

def need_valid_userdesc(desc):
    if has_linebreaks(desc) or not exact_match(userdesc_regex, desc):
        raise GA_Invalid("'{}' is not a valid user desc".format(desc))

def need_valid_domaindesc(desc):
    if has_linebreaks(desc) or not exact_match(domaindesc_regex, desc):
        raise GA_Invalid("'{}' is not a valid domain desc".format(desc))

def need_valid_repodesc(desc):
    if has_linebreaks(desc) or not exact_match(repodesc_regex, desc):
        raise GA_Invalid("'{}' is not a valid repo desc".format(desc))

def need_valid_sshkey_keytype(keytype):
    if not is_word(keytype) or not exact_match(sshkey_keytype_regex, keytype):
        raise GA_Invalid("'{}' is not a valid sshkey keytype".format(keytype))

def need_valid_sshkey_key(key):
    if not is_word(key) or not exact_match(sshkey_key_regex, key):
        raise GA_Invalid("'{}' is not valid (base64-encoded) ssh key".format(key))

def need_valid_sshkey_comment(comment):
    if has_linebreaks(comment) or not exact_match(sshkey_comment_regex, comment):
        raise GA_Invalid("'{}' is not a valid sshkey comment".format(comment))

def need_valid_boolean(boolean):
    if boolean not in ['true', 'false']:
        raise GA_Invalid("'{}' is not a valid boolean. Need 'true' or 'false'".format(boolean))

def need_valid_perm(perm):
    if perm not in ['none','r','rw']:
        raise GA_Invalid("'{}' is not a valid permission mode. Possible: none, r, rw".format(perm))

def need_valid_repospec(word):
    ws = word.split('/')
    if len(ws) != 2:
        GA_Invalid("invalid repo path: {}".format(word))
    domain, repo = ws
    need_valid_domainname(domain)
    need_valid_reponame(repo)
    return domain, repo

def need_cmd_array(cmd_string):
    cmd = ()
    word = ""
    started = False
    quoted = False
    escaped = False
    for char in cmd_string:
        if escaped:
            word += char
            escaped = False
        elif char == '\\':
            escaped = True
            started = True
        elif char == '"':
            quoted = not quoted
            started = True
        elif quoted or char not in ' \t\n\r':
            word += char
            started = True
        elif started:
            cmd = cmd + (word,)
            word = ''
            started = False
    if quoted:
        raise GA_Invalid("Unterminated quote: {}".format(cmd_string))
    if escaped:
        raise GA_Invalid("Trailing escape character: {}".format(cmd_string))
    if started:
        cmd = cmd + (word,)
    return cmd

def need_not_root():
    if loguser is None:
        raise GA_Invalid("You are root admin; this makes no sense")

# **********************************************************************
# Authorization
# **********************************************************************

def require_read_perm(domain, repo):
    assert loguser is not None
    rs = db_list_perms_of_repo_and_user(domain, repo, loguser)
    if not rs:
        raise GA_Unauthorized("{}/{}: No read permission for {}".format(domain, repo, loguser))

def require_write_perm(domain, repo):
    assert loguser is not None
    rs = db_list_perms_of_repo_and_user(domain, repo, loguser)
    if not rs or "rw" not in map(lambda r: r[3], rs):
        raise GA_Unauthorized("{}/{}: No write permission for {}".format(domain, repo, loguser))

def require_regular_user():
    if loguser is not None:
        guests = db_list_guests()
        if loguser in map(lambda r: r[0], loguser):
            raise GA_Unauthorized("you're not a regular user")

def require_host_of_guest(guest):
    if loguser is not None:
        guests = db_list_guests_of_user(loguser)
        if guest not in map(lambda r: r[0], guests):
            raise GA_Unauthorized("that's not one of your guests")

def require_domain_exists(domain):
    rs = db_list_domains()
    if domain not in map(lambda r: r[0], rs):
        raise GA_Unauthorized("no such domain")

def require_repo_exists(domain, repo):
    rs = db_list_repos_of_domain(domain)
    if (domain, repo) not in map(lambda r: (r[0], r[1]), rs):
        raise GA_Unauthorized("no such repo")

def require_domain_admin(domain):
    if loguser is not None:
        rs = db_list_admins_of_domain(domain)
        if loguser not in map(lambda r: r[1], rs):
            raise GA_Unauthorized("domain admin privileges needed")

def require_root_admin():
    if loguser is not None:
        raise GA_Unauthorized("root admin privileges needed")

# **********************************************************************
# Gitadmin commands
# **********************************************************************
# Each command CMD is split in three pieces:
#   valid_CMD(): syntactical validity (regex) for each argument
#   auth_CMD(): authorization
#   task_CMD(): DB + FS transaction
#     DB operations come first because FS operations can't be reverted.
#     State will be left inconsistent when FS fails.

def valid_help():
    return

def valid_whoami():
    return

def valid_list_domains():
    return

def valid_list_repos(domain):
    need_valid_domainname(domain)

def valid_list_users():
    return

def valid_list_admins(domain):
    need_valid_domainname(domain)

def valid_list_perms(domain, repo):
    need_valid_domainname(domain)
    need_valid_reponame(repo)

def valid_list_own_domains():
    need_not_root()

def valid_list_own_perms():
    need_not_root()

def valid_list_own_sshkeys():
    need_not_root()

def valid_list_own_guests():
    need_not_root()

def valid_create_user(user, desc):
    need_valid_username(user)
    need_valid_userdesc(desc)

def valid_delete_user(user):
    need_valid_username(user)

def valid_create_domain(domain, desc):
    need_valid_domainname(domain)
    need_valid_domaindesc(desc)

def valid_delete_domain(domain):
    need_valid_domainname(domain)

def valid_create_repo(domain, repo, desc):
    need_valid_domainname(domain)
    need_valid_reponame(repo)
    need_valid_repodesc(desc)

def valid_delete_repo(domain, repo):
    need_valid_domainname(domain)
    need_valid_reponame(repo)

def valid_set_domain_desc(domain, desc):
    need_valid_domainname(domain)
    need_valid_domaindesc(desc)

def valid_set_repo_desc(domain, repo, desc):
    need_valid_domainname(domain)
    need_valid_reponame(repo)
    need_valid_repodesc(desc)

def valid_set_user_desc(user, desc):
    need_valid_username(user)
    need_valid_userdesc(desc)

def valid_set_repo_public(domain, repo, public):
    need_valid_domainname(domain)
    need_valid_reponame(repo)
    need_valid_boolean(public)

def valid_set_perm(domain, repo, user, perm):
    need_valid_domainname(domain)
    need_valid_reponame(repo)
    need_valid_username(user)
    need_valid_perm(perm)

def valid_set_admin(domain, user, admin):
    need_valid_domainname(domain)
    need_valid_username(user)
    need_valid_boolean(admin)

def valid_add_own_sshkey(keytype, key, comment):
    need_not_root()
    need_valid_sshkey_keytype(keytype)
    need_valid_sshkey_key(key)
    need_valid_sshkey_comment(comment)

def valid_remove_own_sshkey(keytype, key, comment):
    need_not_root()
    need_valid_sshkey_keytype(keytype)
    need_valid_sshkey_key(key)
    need_valid_sshkey_comment(comment)

def valid_create_own_guest(guest, desc, keytype, key, comment):
    need_not_root()
    need_valid_username(guest)
    need_valid_userdesc(desc)
    need_valid_sshkey_keytype(keytype)
    need_valid_sshkey_key(key)
    need_valid_sshkey_comment(comment)

def valid_delete_own_guest(guest):
    need_not_root()
    need_valid_username(guest)

def auth_help():
    return

def auth_whoami():
    return

def auth_list_domains():
    return

def auth_list_repos(domain):
    require_domain_exists(domain)
    require_domain_admin(domain)

def auth_list_users():
    return

def auth_list_admins(domain):
    require_domain_exists(domain)
    require_domain_admin(domain)

def auth_list_perms(domain, repo):
    require_domain_exists(domain)
    require_domain_admin(domain)

def auth_list_own_domains():
    return

def auth_list_own_perms():
    return

def auth_list_own_sshkeys():
    return

def auth_list_own_guests():
    return

def auth_create_user(user, desc):
    require_root_admin()

def auth_delete_user(user):
    require_root_admin()

def auth_create_domain(domain, desc):
    require_root_admin()

def auth_delete_domain(domain):
    require_root_admin()

def auth_create_repo(domain, repo, desc):
    require_domain_exists(domain)
    require_domain_admin(domain)

def auth_delete_repo(domain, repo):
    require_domain_exists(domain)
    require_domain_admin(domain)

def auth_set_domain_desc(domain, desc):
    require_domain_exists(domain)
    require_domain_admin(domain)

def auth_set_repo_desc(domain, repo, desc):
    require_domain_exists(domain)
    require_domain_admin(domain)

def auth_set_user_desc(user, desc):
    require_root_admin()

def auth_set_repo_public(domain, repo, public):
    require_domain_exists(domain)
    require_domain_admin(domain)
    require_repo_exists(domain, repo)

def auth_set_perm(domain, repo, user, perm):
    require_domain_exists(domain)
    require_domain_admin(domain)

def auth_set_admin(domain, user, admin):
    require_domain_exists(domain)
    require_domain_admin(domain)

def auth_add_own_sshkey(keytype, key, comment):
    return

def auth_remove_own_sshkey(keytype, key, comment):
    return

def auth_create_own_guest(guest, desc, keytype, key, comment):
    require_regular_user()

def auth_delete_own_guest(guest):
    require_host_of_guest(guest)

def task_help():
    return [[commands_listing]]

def task_whoami():
    return [[loguser or '(root)']]

def task_list_domains():
    return db_list_domains()

def task_list_repos(domain):
    return db_list_repos_of_domain(domain)

def task_list_users():
    return db_list_users()

def task_list_admins(domain):
    return db_list_admins_of_domain(domain)

def task_list_perms(domain, repo):
    return db_list_perms_of_repo(domain, repo)

def task_list_own_domains():
    return db_list_domains_of_user(loguser)

def task_list_own_perms():
    return db_list_perms_of_user(loguser)

def task_list_own_sshkeys():
    return db_list_sshkeys_of_user(loguser)

def task_list_own_guests():
    return db_list_guests_of_user(loguser)

def task_create_user(user, desc):
    db_insert_user(user, desc)

def task_delete_user(user):
    db_delete_user(user)
    fs_write_authorized_keys(db_list_sshkeys())

def task_create_domain(domain, desc):
    db_insert_domain(domain, desc)
    fs_make_domain_dir(domain)
    fs_make_publicro_domain_dir(domain)

def task_delete_domain(domain):
    db_delete_domain(domain)
    fs_remove_domain_dir(domain)
    fs_remove_publicro_domain_dir(domain)

def task_create_repo(domain, repo, desc):
    db_insert_repo(domain, repo, desc)
    fs_create_repo(domain, repo)
    fs_set_repo_desc(domain, repo, desc)

def task_delete_repo(domain, repo):
    db_delete_repo(domain, repo)
    fs_delete_repo(domain, repo)

def task_set_domain_desc(domain, desc):
    db_update_domain_desc(domain, desc)

def task_set_repo_desc(domain, repo, desc):
    db_update_repo_desc(domain, repo, desc)
    fs_set_repo_desc(domain, repo, desc)

def task_set_user_desc(user, desc):
    db_update_user_desc(user, desc)

def task_set_repo_public(domain, repo, public):
    rs = db_list_publicro_of_repo(domain, repo)
    if public == 'true' and not rs:
        db_set_publicro(domain, repo)
        fs_set_publicro_symlink(domain, repo)
    elif public == 'false' and rs:
        db_clear_publicro(domain, repo)
        fs_clear_publicro_symlink(domain, repo)

def task_set_perm(domain, repo, user, perm):
    if perm == 'none':
        db_clear_perm(domain, repo, user)
    else:
        db_set_perm(domain, repo, user, perm)

def task_set_admin(domain, user, admin):
    if admin == 'true':
        db_set_admin(domain, user)
    else:
        db_clear_admin(domain, user)

def task_add_own_sshkey(keytype, key, comment):
    db_insert_sshkey(loguser, keytype, key, comment)
    fs_write_authorized_keys(db_list_sshkeys())

def task_remove_own_sshkey(keytype, key, comment):
    db_delete_sshkey(loguser, keytype, key)
    fs_write_authorized_keys(db_list_sshkeys())

def task_create_own_guest(guest, desc, keytype, key, comment):
    db_insert_user(guest, desc)
    db_set_host(loguser, guest)
    db_insert_sshkey(guest, keytype, key, comment)
    fs_write_authorized_keys(db_list_sshkeys())

def task_delete_own_guest(guest):
    db_clear_host(loguser, guest)
    db_delete_user(guest)
    fs_write_authorized_keys(db_list_sshkeys())

# **********************************************************************
# Command execution
# **********************************************************************

def run_cmd_array(args):
    global loguser

    if not args:
        return

    user = loguser

    if user is None and len(args) >= 2 and args[0] == 'su':
        user = args[1]
        args = args[2:]
        if not args:
            raise GA_Invalid('"su" needs a command to run: su <user> <cmd...>')

    cmdlow = args[0].replace('-', '_')

    auth  = globals().get('auth_'  + cmdlow)
    valid = globals().get('valid_' + cmdlow)
    task  = globals().get('task_'  + cmdlow)

    if auth is None or valid is None or task is None:
        raise GA_Invalid("No such command: " + args[0])

    auth_spec  = inspect.getargspec(auth)
    valid_spec = inspect.getargspec(valid)
    task_spec  = inspect.getargspec(task)

    assert auth_spec == valid_spec == task_spec

    if ((task_spec[1] is None and len(args) - 1 != len(task_spec[0])) or
        (task_spec[1] is not None and len(args) - 1 < len(task_spec[0]))):
        raise GA_Invalid("too few or too many arguments. Usage: {} {}".format(args[0], ' '.join(x.upper() for x in task_spec[0])))

    realuser = loguser
    loguser = user

    try:
        valid(*args[1:])

        def execute():
            auth(*args[1:])
            return task(*args[1:])
        rs = run_transaction(execute)

        if rs is not None:
            if is_stdout_tty:
                out = format_table(rs)
            else:
                out = ''.join('\t'.join(c for c in r) + '\n' for r in rs)
            sys.stdout.write(out)
    finally:
        loguser = realuser

class GitAdminShell(cmd.Cmd):
    intro = shell_intro
    prompt = shell_prompt

    def __init__(self):
        # Override the bad default to output prompts to sys.stdout.
        # The docs don't hint that the completekey default argument of 'Tab' is
        # really a string (!). Giving None instead doesn't restore the default
        # behaviour but instead disables completion -- but hey, that saved one
        # configuration option.
        super().__init__('Tab', sys.stdin, sys.stderr)

        if loguser is None:
            print("Starting root admin shell...", file=sys.stderr)
        else:
            print("Logged in as {}".format(loguser), file=sys.stderr)

    # Override this method because the default is to repeat the last command.
    def emptyline(self):
        pass

    def default(self, line):
        # 'EOF' (a string) is used to indicate EOF on stdin.
        # And why do we need to handle this at all by default?
        if line in ['EOF', 'exit', 'quit']:
            if line == 'EOF':
                print(file=sys.stderr)
            # indicate that the interpreter should be ended
            return True
        else:
            run_cmd_array(need_cmd_array(line))

    # Override this method to be able to handle exceptions from commands
    def onecmd(self, line):
        try:
            # All commands should return None, except default() above where we
            # return True for EOF, exit, or quit
            return super().onecmd(line)
        except (GA_Invalid,
                GA_Unauthorized,
                GA_NotFound,
                GA_Exists,
                GA_FailedDependencies) as e:
            print("ERROR: {}".format(e), file=sys.stderr)
            return False

    # Override this method because keyboard interrupts at the prompt
    # can't be handled in onecmd()
    def cmdloop(self):
        while True:
            try:
                return super().cmdloop()
            except KeyboardInterrupt as e:
                print(file=sys.stderr)
                # make sure intro won't be displayed again.
                self.intro = None

# By default, the built-in do_help command prints a barely useful compilation of
# registered do_* commands. Also, "help" is autocompleted. This is evil:
delattr(cmd.Cmd, 'do_help')

# **********************************************************************
# Transparent repo access
# **********************************************************************

def exec_git_upload_pack(spec):
    domain, repo = need_valid_repospec(spec)
    require_read_perm(domain, repo)
    repopath = path_repo_dir(domain, repo)
    os.execvp("git-upload-pack", ["git-upload-pack", repopath])

def exec_git_receive_pack(spec):
    domain, repo = need_valid_repospec(spec)
    require_write_perm(domain, repo)
    repopath = path_repo_dir(domain, repo)
    os.execvp("git-receive-pack", ["git-receive-pack", repopath])

# **********************************************************************
# Main
# **********************************************************************

def invoke_help():
    print(help_long)

def invoke_init():
    try:
        fs_initialize()
    except GA_FSError as e:
        print("Initialization failed: {}".format(e), file=sys.stderr)
        sys.exit(13)

def invoke_with_cmdarray(cmd_array):
    with_db(run_cmd_array, cmd_array)

def invoke_with_cmdstring(cmd_string):
    cmd_array = need_cmd_array(cmd_string)
    with_db(run_cmd_array, cmd_array)

def invoke_with_sshoriginalcommand(ssh_original_command):
    ws = tuple(shlex.split(ssh_original_command))
    if len(ws) == 2 and ws[0] == 'git-upload-pack':
        with_db(exec_git_upload_pack, ws[1])
    elif len(ws) == 2 and ws[0] == 'git-receive-pack':
        with_db(exec_git_receive_pack, ws[1])
    elif len(ws) >= 2 and ws[0] == 'gitadmin':
        with_db(run_cmd_array, ws[1:])
    else:
        raise GA_Invalid("Invalid invocation (SSH_ORIGINAL_COMMAND): need \"git-(upload|receive)-pack 'DOMAIN/REPO'\" or \"gitadmin <GITADMIN-CMD>\"")

def invoke_shell():
    if is_stdin_tty and is_stderr_tty:
        shell = GitAdminShell()
        with_db(shell.cmdloop)
    else:
        for line in sys.stdin:
            with_db(run_cmd_array, need_cmd_array(line))

def gitadmin(argv, ssh_original_command=None):
    global loguser

    argv = tuple(argv[1:])

    wantinit = None
    wanthelp = None
    req_user = None
    cmd_string = None
    cmd_array = None

    if len(argv) >= 1 and argv[0] == '--init':
        wantinit = ()
        argv = argv[1:]
    if len(argv) >= 1 and argv[0] == '--help':
        wanthelp = ()
        argv = argv[1:]
    if len(argv) >= 2 and argv[0] == '-u':
        req_user = argv[1]
        argv = argv[2:]
    if len(argv) >= 2 and argv[0] == '-c':
        cmd_string = argv[1]
        argv = argv[2:]
    if len(argv) and not argv[0].startswith('-'):
        cmd_array = tuple(argv)
        argv = ()

    if len(argv):
        raise GA_CLIError()

    def exclusive(*opts):
        notnone = [o for o in opts if o is not None]
        if len(notnone) > 1:
            raise GA_CLIError()

    exclusive(wantinit, wanthelp, cmd_array, cmd_string)
    exclusive(wantinit, wanthelp, req_user)

    # login. Logout is when program quits
    loguser = req_user

    if wanthelp is not None:
        invoke_help()
    elif wantinit is not None:
        invoke_init()
    elif cmd_array is not None:
        invoke_with_cmdarray(cmd_array)
    elif cmd_string is not None:
        invoke_with_cmdstring(cmd_string)
    elif ssh_original_command is not None:
        invoke_with_sshoriginalcommand(ssh_original_command)
    else:
        invoke_shell()

if __name__ == '__main__':
    try:
        gitadmin(sys.argv, os.getenv('SSH_ORIGINAL_COMMAND'))
        sys.exit(0)
    except GA_CLIError as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        print("gitadmin: call \"gitadmin --help\"", file=sys.stderr)
        sys.exit(1)
    except GA_Invalid as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(2)
    except GA_Unauthorized as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(3)
    except GA_NotFound as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(4)
    except GA_Exists as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(5)
    except GA_FailedDependencies as e:
        print("gitadmin: ERROR: {}".format(e), file=sys.stderr)
        sys.exit(6)
    except (GA_DBError, GA_FSError, Exception) as e:
        print("gitadmin: ERROR: Oops! {}. Please contact your system or network administrator".format(e), file=sys.stderr)
        sys.exit(13)
